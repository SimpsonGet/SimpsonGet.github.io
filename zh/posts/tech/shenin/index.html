<!DOCTYPE html>
<html lang="zh" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>海外电商APP希Y某参数分析 | Simpson&#39;s Blog</title>
<meta name="keywords" content="unidbg分析, 算法分析, 花指令">
<meta name="description" content="海外电商APP希Y某的armortoken参数生成算法逆向分析">
<meta name="author" content="simpson">
<link rel="canonical" href="https://SimpsonGet.github.io/zh/posts/tech/shenin/">

 <link crossorigin="anonymous" href="/assets/css/stylesheet.36819bea596090d8b48cf10d9831382996197aa7e4fc86f792f7c08c9ca4d23b.css" integrity="" rel="preload stylesheet" as="style">
<link rel="icon" href="https://SimpsonGet.github.io/img/logo.gif">
<link rel="icon" type="image/png" sizes="16x16" href="https://SimpsonGet.github.io/img/logo.gif">
<link rel="icon" type="image/png" sizes="32x32" href="https://SimpsonGet.github.io/img/logo.gif">
<link rel="apple-touch-icon" href="https://SimpsonGet.github.io/logo.gif">
<link rel="mask-icon" href="https://SimpsonGet.github.io/logo.gif">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="zh" href="https://SimpsonGet.github.io/zh/posts/tech/shenin/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:url" content="https://SimpsonGet.github.io/zh/posts/tech/shenin/">
  <meta property="og:site_name" content="Simpson&#39;s Blog">
  <meta property="og:title" content="海外电商APP希Y某参数分析">
  <meta property="og:description" content="海外电商APP希Y某的armortoken参数生成算法逆向分析">
  <meta property="og:locale" content="zh">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2025-07-13T23:08:05+08:00">
    <meta property="article:modified_time" content="2025-07-13T23:08:05+08:00">
    <meta property="article:tag" content="Unidbg">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="海外电商APP希Y某参数分析">
<meta name="twitter:description" content="海外电商APP希Y某的armortoken参数生成算法逆向分析">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://SimpsonGet.github.io/zh/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Tech",
      "item": "https://SimpsonGet.github.io/zh/posts/tech/"
    }, 
    {
      "@type": "ListItem",
      "position":  3 ,
      "name": "海外电商APP希Y某参数分析",
      "item": "https://SimpsonGet.github.io/zh/posts/tech/shenin/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "海外电商APP希Y某参数分析",
  "name": "海外电商APP希Y某参数分析",
  "description": "海外电商APP希Y某的armortoken参数生成算法逆向分析",
  "keywords": [
    "unidbg分析", "算法分析", "花指令"
  ],
  "articleBody": "着手该app逆向分析是因为看到wx公众号Frida and So的一篇文章，该公众号文章一如既往的言简意赅，因此尝试分析最新版本并补充细节。（如侵立删！）\n软件\tSH*IN v13.0.2\n包名 com.z*kko\n抓包 希音反爬的参数校验（armortoken、anti-in、smdeviceid）\n针对armortoken这个参数\njava层分析参数来源 关键词搜索定位\n这里GDA分析出来的逻辑明显有问题！（str=str1后没返回，返回一个exception你什么意思）\n换jadx继续分析\n使用frida hook这里的SiArmorProxy.f中的str确实就是armortoken的来源\n1 2 com.shein.armor.a.a 参数（12, null) 使用ArtMethod中data段，来定位JNI函数的偏移和库\naddress : 0x71e2741cc0 offset: 0x77cc0 module : libsi_armor.so\nnative层分析 so文件：libsi_armor.so\n函数：public static native Object a(int i2, Object obj);\n参数：a(12, null);\n花指令去除 进入到JNI方法偏移处，观察到有花指令\n汇编指令分析\n其实最后跳转的地方就是 SUB X0, X0 #8 这段.text段的地址 + 0x44\n继续跟踪，跳转过去还有跳转\n1 2 3 4 5 6 7 8 9 10 11 12 13 #间接处理跳转地址的函数 1、sub_77D4C (makeX0NextAddrAdd8) 将x0设为LR + 8 2、sub_77DC8 (makeX0NextAddr) x0 = LR 3、sub_77E38\t(_makeX0NextAddr) x0 = LR 4、sub_77E88 (同1) x0 = LR + 0x8 ...... 这是根据上面的JNI函数跟踪先手动总结的，可能不完全\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 总结一下跳转的类型（是否以间接处理的函数地址来作为判断依据比较好？PASS，因为有些很多内容相同但函数名不同的） 1、跳转地址为SUB X0, X0 #8 这段.text段的地址 + 0x44 BL sub_77D4C; SUB X0, X0, #8 ;\t00 20 00 D1 ADD X1, X0, #0x44 ; 'D' ; 01 10 01 91 BR X1 20 00 1F D6 2、跳转地址为 ADD X0，X0,#8 的地址 + 0x10 （0x8 + 0x8） BL sub_77D4C ; ADD X0, X0, #8 ;\t00 20 00 91 BR X0\t00 00 1F D6 3、跳转地址为 MOV X9, X0 的地址 + 0x60 BL sub_77DC8 ; MOV X9, X0\tE9 03 00 AA ADD X9, X9, #0x60 ; '`' ; 29 81 01 91 BR X9\t20 01 1F D6 4、跳转地址为 MOV X2, X0 的地址 + 0x34 BL sub_77E38 MOV X2, X0 ;\tE2 03 00 AA ADD X2, X2, #0x34 ; 42 D0 00 91 BR X2\t40 00 1F D6 只去除了部分，没有完全复原……不过已经好看了一些\nunidbg动态分析 构造调用a函数，之前分析快手的时候遇到过这种情况，其实还有初始化的函数没有调用\n回过头看java层确实需要调用initNative这个JNI函数\n漫长的补环境环节。。。利用frida去获得一些补环境的参数\n（在分析java层的时候还是结合多个反编译工具一起看吧）\n部分补环境的记录 这里com.shein.armor.a.b-\u003eb.overload(‘int’, “java.lang.Object”)方法以frida获得的结果补充\n太好了没多少环境要补，成功模拟出a函数的返回值，也就是armortoken参数的值\n1 2 3 4 5 6 7 8 #armortoken 长度0xD7 S2_3.3.5_Mv5PMqZ_w1zWL3VJfh7u-gwZRe_pO2RPE7C8JADr6EkDQR-iIzEEoqUdBgopOSWFkmorVqkVsuDzI81g26-G3lYExP6Sjmk8OyKbC7xVBJsUaa8WAZujzwBHDko-J_OtQ_PLc0XMuykK0896NckPX4VLjaEYumZ9BogyGhRW-zAosnFMUsq6SXsf6mFIDVEr_1752294024718 #参数构成 固定标识 SDK版本 加密字段 时间戳 具体分析 根据unidbg输出日志JNIEnv-\u003eNewStringUTF was called from RX@0x120804d4[libsi_armor.so]0x794d4\n定位到0x794d4\n在此处下断点，确实就是这个\n老方法trace write 0x122dc1c0，开启溯源模式，定位到0x4993c，是memcpy函数\n从tracelog中找到源数据来源于0x122dc0e0\n还是从0x4993c的memcpy去分析，（在sub_49350中）\n在0x49840的前后下断点，查看mx0的值，可以确定写入点就在这，将v57 + 时间戳拼接写入目标地址\n根据前面的分析总体为（固定标识，SDK版本，加密字段，时间戳），现在称（固定标识，SDK版本，加密字段）为前缀\n所以构成为 前缀 + 时间戳\n前缀 根据tracelog可以确定是真条件下的值，这里是获取otherdata的地址，trace 0x122dc2a0 找到写入点\n0x49468\n在该vsnprint处下断点\n1 2 v43 = 0xca 长度正确✔ 构造_ohterdata = \"S\" + \"2\" + a13 + v46 固定标识 “S” + “2”\nsdk版本 a13 0xe4fff449\n1 [18:05:56 245] Memory WRITE at 0xe4fff449, data size = 4, data value = 0x2e332e33, PC=RX@0x1204f9cc[libsi_armor.so]0x489cc, LR=RX@0x1204f520[libsi_armor.so]0x48520 根据tracewrite定位到写入点（sub_486F4——0x489cc）\n加密字段 0x122dc0e0 ，长度为0xb0\n定位到0x2ec98 是memove函数\nmemove是从0x122dc1c0赋值的数据，\n观察到先在0x2ea28调用处赋值，再0x2ebd8处覆盖2f—\u003e5f; 2b—\u003e2d\n0x122dc1c0定位到0x2EA24处是memcpy，在sub_3C8FC前后断点，可以发现，加密数据就是在sub_3C8FC中生成的\n[sub_3C8FC]Base64 一共两次调用该函数\n**summary：**0x90是待base64编码的数据长度，a4参数是待编码数据\n1 2 3 4 sub_3C8FC(__encryptData, v11, size, v17, v18); 1、（0，0， size的指针，指针 ，0x90） 根据0x90是否为3的倍数，进行size = (4 * (0x90 / 3)) | 1; 2、（0x122dc0e0（指针）， 0xC1， size指针，指针（原始数据），0x90) base64编码\n1 2 3 4 #特征 每次循环读取三字节，写入四字节 使用右移 \u003e\u003e、与 \u0026、或 | 来组合 6-bit 的值 所有位运算结果都被当作索引查一个数组 将输入数组 a4 中的内容按 3 字节一组，编码成 4 字节的 Base64 字符，写入 _reulst_ptr。\n1 2 base64字符表 byte_19188 = 'a-z','A-Z',0-9,+, \"/\" 验证是标准的base64编码\n所以sub_3C8FC的a4就是base64前的数据，0x122eb0a0， 长度0x90\n1 2 3 4 5 6 7 8 9 0000: 32 FE 4F 32 A6 7F C3 5C D6 2F 75 49 7E 1E EE FA 2.O2...\\./uI~... 0010: 0C 19 45 EF E9 3B 64 4F 13 B0 BC 24 00 EB E8 49 ..E..;dO...$...I 0020: 03 41 1F A2 23 31 04 A2 A5 1D 06 0A 29 39 25 85 .A..#1......)9%. 0030: 92 6A 2B 56 A9 15 B2 E0 F3 23 CD 60 DB AF 86 DE .j+V.....#.`.... 0040: 56 04 C4 FE 92 8E 69 3C 3B 22 9B 0B BC 55 04 9B V.....i\u003c;\"...U.. 0050: 14 69 AF 16 01 9B A3 CF 00 47 0E 4A 3E 27 F3 AD .i.......G.J\u003e'.. 0060: 3F CB F6 EC 3D 41 AC 71 49 5E 6E E5 AA 31 BE 41 ?...=A.qI^n..1.A 0070: 71 72 60 B2 9F 72 44 AF 6A FD 8F BF 0A B4 62 47 qr`..rD.j.....bG 0080: A8 13 51 98 86 4F 0B EB AD 2E ED 84 CF 81 51 2B ..Q..O........Q+ 0x2e8ec\n[sub_39a40] 跳转到0x398D8\n1 2 __int64 __fastcall sub_398D8(_BYTE *a1, __int64 a2, _OWORD *a3, unsigned int a4) a2，a3为0x122eb0a0待base64加密数据的指针 a2=a3=2+sdk版本+jni环境中的值com/shein/armor/a/b-b + android/os/Build-\u003eBRAND + android/os/Build-\u003eMODEL + 时间戳+？？？（这里的691724686）+ ？？？（c7cd4b） 且每个之间以^@拼接\n最后以PKCS7填充\n​\t是某种分组加密算法，继续分析\ndowhile 循环0x9次\n每次处理a2中的（ a2 ~ a2 +7+8）16个字节的数据，每次循环结束后a2 + 16\n1 2 3 4 5 6 7 8 9 10 9x122eb0a0 ~ 0x122eb0af ...... 0x122eb0a0 ~ 0x122eb120 a1[488] = a1[488] ^ a2 a1[489] = a1[489] ^ (a2 + 1) a1[490] = a1[490] ^ (a2 + 2) ...... a1[503] = a1[503] ^ (a2 + 15) 再进入 sub_3984C 函数，将结果位置的v7存在a3中\na1[488~503] 是迭代状态\n根据tracelog可以看出，这里的v7也是16字节，a2和a3一开始是相同指针地址，所以这里v9后续取的也就是sub_3984C处理后的数据\n所以更加推断是AES的CBC模式，接下去去获取iv和key\n[sub_3984C] 核心 根据这几个表索引查到其实是TE表1-4，用于查找表优化\ntrace sub_394F4返回前 0xe4fff2d0L的内存，就是最后的密文\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 ======================sub_394F4================================= 0000: 32 5E 40 5E 33 2E 33 2E 35 5E 40 5E 31 64 30 35 2^@^3.3.5^@^1d05 ======================sub_394F4================================= 0000: 57 9A 78 0A C5 4E A6 6C E7 1C 41 2D 4B 7A D6 CF W.x..N.l..A-Kz.. ======================sub_394F4================================= 0000: 39 2F 76 DF D1 0E 56 79 24 88 DA 40 39 8D DC 2A 9/v...Vy$..@9..* ======================sub_394F4================================= 0000: 65 79 7A C0 16 09 62 90 9C 24 67 68 4A 0E 16 BC eyz...b..$ghJ... ======================sub_394F4================================= 0000: F3 5F 18 63 9F 74 D7 84 CB 47 FE 02 85 EF D8 B9 ._.c.t...G...... ======================sub_394F4================================= 0000: 39 6B A3 92 F7 D0 29 62 75 47 E3 7E CF 75 32 CB 9k....)buG.~.u2. ======================sub_394F4================================= 0000: 4A 29 F1 27 36 AE 91 FC 38 7E 37 78 0B 17 C0 99 J).'6...8~7x.... ======================sub_394F4================================= 0000: BE 7C 1E 43 FC 8E 02 81 05 6D DA C1 A3 C1 E8 D2 .|.C.....m...... ======================sub_394F4================================= 0000: 37 96 2C EC E2 89 2D 56 DD D5 6A 83 11 99 33 76 7.,...-V..j...3v 输入前 输入后sub_394F4\n在0x398D8断点，\n因为a1[488..503]：被不断 xor 操作，结合前面的分析，可以确定是 CBC 的IV = 0000000000000000\n在9次循环下断点，每次的a1 + 488 第一次全0，后续都是上一次的结果，符合aesCBC\n第一轮的才是初始iv\n这几行表示用 a1 地址处的前 16 字节（即 a1 + 0 到 a1 + 16）分别和传入明文块（大端转小端后）做 XOR。\n（a1其实包括了 key、iv、轮密钥这些数据）\n密钥Gibw1p_aX\u0026!0o+_G\t一开始以为是这个卡住了\n每四字节读取作为密钥为\nwbiGa_p10!\u0026XG_+o\n成功恢复，iv和key正确\n明文数据的来源 1 2 3 4 5 6 7 8 9 10 11 12 #0x122eb000 0000: 32 5E 40 5E 33 2E 33 2E 35 5E 40 5E 31 64 30 35 2^@^3.3.5^@^1d05 0010: 65 64 37 38 63 31 65 30 31 33 34 64 35 64 38 35 ed78c1e0134d5d85 0020: 35 36 33 30 38 35 32 36 37 38 66 64 39 66 34 63 5630852678fd9f4c 0030: 66 38 65 62 35 38 66 32 39 39 61 62 63 37 33 39 f8eb58f299abc739 0040: 61 35 33 35 36 61 65 64 38 64 33 62 5E 40 5E 67 a5356aed8d3b^@^g 0050: 6F 6F 67 6C 65 5E 40 5E 4E 65 78 75 73 20 36 50 oogle^@^Nexus 6P 0060: 5E 40 5E 31 37 35 32 33 39 34 33 37 31 35 32 30 ^@^1752394371520 0070: 5E 40 5E 34 32 38 30 34 30 33 30 31 5E 40 5E 38 ^@^428040301^@^8 0080: 36 61 34 64 31 0B 0B 0B 0B 0B 0B 0B 0B 0B 0B 0B 6a4d1........... 2+sdk版本+jni环境中的值com/shein/armor/a/b-b + android/os/Build-\u003eBRAND + android/os/Build-\u003eMODEL + 时间戳+？？？1（这里的691724686）+ ？？？2（c7cd4b） 且每个之间以^@拼接 【1】随机数（以时间戳为种子生成）\n0x48d60找到048D60处的memcpy\n剩下三个参数由栈传递\n1 2 %d\t^@^\t%s\t^@^\t%s\t^@^ %s ^@^ %s ^@^ %s ^@^ %d 2 3.3.5\t1d... google Nexus 6P 1752412831975 853602514 拼接jni environment中的参数\n这个参数就是以时间戳为种子生成的随机数\n​\t存储在0x122d6100中\n【2】md5[-6:]\n前面一共0x7C\n这里添加0x405e32 “^@^”\n在0x83764处的memove处下断点\nLR=RX@0x120500d8[libsi_armor.so]0x490d8\n0xe4fff3b9 0x838b4 0x122d30aa 0x49014\n在进入0x838b4 （sub_83814时，0x122d30aa 就已经有该值了 ） ，所以和 a2和a3有关\n一开始没有trace到，是因为直接trace了0x122d30aa -0x122d30aa +0x6的范围，扩大范围0x36520\nsub_3639C对a1+1的地址进行hex编码得到最后段数据\n在sub_3AD9C断点，对比前后\u0026v18的结果 因为花指令取出不完整，采用对照trace的跳转地址\n最后进入 sub_3A1E4 （大量的位操作 (\u0026, |, ~, \u003e\u003e) 大量固定的魔法数字 (Magic Numbers)，例如 -389564586, 606105819, -1044525330, -176418897, 1200080426, -1473231341），就是md5加密\n在线验证，是未魔改的md5\n2其实是对前面的数据进行md5后取后6位\n过程中发现密钥是硬编码\n覆盖 在0x2ebfc处覆盖2f—\u003e5f; 2b—\u003e2d\n时间戳 通过gettimeofday函数获取时间戳加入到armortokenstr的末尾\n总结 armortoken 参数生成方式：\n固定标识 \"S\" + \"2\"\nSDK 版本号（例如 3.3.5）\n密文数据：\ncom/shein/armor/a/b-b的值、设备品牌（android/os/Build-\u003eBRAND）、设备型号（android/os/Build-\u003eMODEL）\n、时间戳、一个以时间戳为种子生成的随机数、由前面数据以及^@^构成的数据进行 MD5 加密后截取后 6 位的值，并可能在末尾进行 PKCS7 填充。 构成明文数据，在使用AES-256 加密算法的 CBC 模式进行加密，然后将 2f (ASCII ‘/’) 替换为 5f (ASCII ‘_’)，将 2b (ASCII ‘+’) 替换为 2d (ASCII ‘-’)，再进行HEX编码，最后进行base64编码\n额外知识点 补充一下一些内容\nunidbg中callStaticJniMethod 和 Module.callFunction 方式调用JNI函数的区别和优劣\ncallStaticJniMethod 通过 JNI 层调用 Java 方法\n​\t通过模拟 Java 层调用 JNI 方法，是通过 DalvikVM 来模拟 Android Java 层代码执行，部会模拟 JNI 注册，参数转换，以及回调 Native 层。\n​\t逻辑性较完整，因为是模拟的从java层去调用，适合注册了native的方法\nmodule.callFunction 直接调用 native 函数地址\n​\t直接调用 SO 文件中某个函数的地址，跳过 Java 层、JNI 封装，直接进入 native 层执行函数代码。\n​\t直接调用特定函数，可用于定位、反调试、HOOK 点、内部逻辑执行。\nNumber number = module.callFunction() 这个 number 的意义是：\n如果 native 函数返回的是一个整数（如 int 或 jint），你可以用 number.intValue()\n如果函数返回一个对象（如 jstring 或其他 jobject），那么返回值是该对象在虚拟机中的 reference ID\n安卓系统静态常量（用于部分环境补充）\n字段 命令 示例返回 Build.BRAND adb shell getprop ro.product.brand google Build.MODEL adb shell getprop ro.product.model MI 9 Build.MANUFACTURER adb shell getprop ro.product.manufacturer Xiaomi Build.DEVICE adb shell getprop ro.product.device cepheus Build.FINGERPRINT adb shell getprop ro.build.fingerprint Xiaomi/cepheus/cepheus:10/QKQ1... Build.VERSION.SDK_INT adb shell getprop ro.build.version.sdk 30 Build.VERSION.RELEASE adb shell getprop ro.build.version.release 11 参考资料 https://mp.weixin.qq.com/s/nvNCmXXAbstYZUkxDZ9ZnQ\nhttps://www.cnblogs.com/kentle/p/15529251.html\n",
  "wordCount" : "4741",
  "inLanguage": "zh",
  "datePublished": "2025-07-13T23:08:05+08:00",
  "dateModified": "2025-07-13T23:08:05+08:00",
  "author":[{
    "@type": "Person",
    "name": "simpson"
  }],
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://SimpsonGet.github.io/zh/posts/tech/shenin/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Simpson's Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://SimpsonGet.github.io/img/logo.gif"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://SimpsonGet.github.io/zh/" accesskey="h" title="Simpson&#39;s Blog (Alt + H)">Simpson&#39;s Blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://SimpsonGet.github.io/zh/search" title="🔍搜索 (Alt &#43; /)" accesskey=/>
                    <span>🔍搜索</span>
                </a>
            </li>
            <li>
                <a href="https://SimpsonGet.github.io/zh/" title="🏠主页">
                    <span>🏠主页</span>
                </a>
            </li>
            <li>
                <a href="https://SimpsonGet.github.io/zh/posts" title="📚文章">
                    <span>📚文章</span>
                </a>
            </li>
            <li>
                <a href="https://SimpsonGet.github.io/zh/tags" title="🔖标签">
                    <span>🔖标签</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://SimpsonGet.github.io/zh/">主页</a>&nbsp;»&nbsp;<a href="https://SimpsonGet.github.io/zh/posts/">Posts</a>&nbsp;»&nbsp;<a href="https://SimpsonGet.github.io/zh/posts/tech/">Tech</a></div>
    <h1 class="post-title entry-hint-parent">
      海外电商APP希Y某参数分析
    </h1>
    <div class="post-meta"><span title='2025-07-13 23:08:05 +0800 CST'>2025-07-13</span>&nbsp;·&nbsp;10 分钟&nbsp;·&nbsp;simpson

</div>
  </header> <div class="toc">
    <details  open>
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">目录</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#%e6%8a%93%e5%8c%85" aria-label="抓包">抓包</a></li>
                <li>
                    <a href="#java%e5%b1%82%e5%88%86%e6%9e%90%e5%8f%82%e6%95%b0%e6%9d%a5%e6%ba%90" aria-label="java层分析参数来源">java层分析参数来源</a></li>
                <li>
                    <a href="#native%e5%b1%82%e5%88%86%e6%9e%90" aria-label="native层分析">native层分析</a><ul>
                        
                <li>
                    <a href="#%e8%8a%b1%e6%8c%87%e4%bb%a4%e5%8e%bb%e9%99%a4" aria-label="花指令去除">花指令去除</a></li>
                <li>
                    <a href="#unidbg%e5%8a%a8%e6%80%81%e5%88%86%e6%9e%90" aria-label="unidbg动态分析">unidbg动态分析</a><ul>
                        
                <li>
                    <a href="#%e9%83%a8%e5%88%86%e8%a1%a5%e7%8e%af%e5%a2%83%e7%9a%84%e8%ae%b0%e5%bd%95" aria-label="部分补环境的记录">部分补环境的记录</a></li>
                <li>
                    <a href="#%e5%85%b7%e4%bd%93%e5%88%86%e6%9e%90" aria-label="具体分析">具体分析</a><ul>
                        
                <li>
                    <a href="#%e5%89%8d%e7%bc%80" aria-label="前缀">前缀</a><ul>
                        
                <li>
                    <a href="#%e5%9b%ba%e5%ae%9a%e6%a0%87%e8%af%86" aria-label="固定标识">固定标识</a></li>
                <li>
                    <a href="#sdk%e7%89%88%e6%9c%ac" aria-label="sdk版本">sdk版本</a></li>
                <li>
                    <a href="#%e5%8a%a0%e5%af%86%e5%ad%97%e6%ae%b5" aria-label="加密字段">加密字段</a><ul>
                        
                <li>
                    <a href="#sub_3c8fcbase64" aria-label="[sub_3C8FC]Base64">[sub_3C8FC]Base64</a></li>
                <li>
                    <a href="#sub_39a40" aria-label="[sub_39a40]">[sub_39a40]</a></li>
                <li>
                    <a href="#sub_3984c-%e6%a0%b8%e5%bf%83" aria-label="[sub_3984C] 核心">[sub_3984C] 核心</a></li>
                <li>
                    <a href="#%e6%98%8e%e6%96%87%e6%95%b0%e6%8d%ae%e7%9a%84%e6%9d%a5%e6%ba%90" aria-label="明文数据的来源">明文数据的来源</a></li>
                <li>
                    <a href="#%e8%a6%86%e7%9b%96" aria-label="覆盖">覆盖</a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#%e6%97%b6%e9%97%b4%e6%88%b3" aria-label="时间戳">时间戳</a></li></ul>
                </li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#%e6%80%bb%e7%bb%93" aria-label="总结">总结</a></li>
                <li>
                    <a href="#%e9%a2%9d%e5%a4%96%e7%9f%a5%e8%af%86%e7%82%b9" aria-label="额外知识点">额外知识点</a></li>
                <li>
                    <a href="#%e5%8f%82%e8%80%83%e8%b5%84%e6%96%99" aria-label="参考资料">参考资料</a>
                </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><p>着手该app逆向分析是因为看到wx公众号<code>Frida and So</code>的一篇文章，该公众号文章一如既往的言简意赅，因此尝试分析<strong>最新版本</strong>并补充细节。（<strong>如侵立删！</strong>）</p>
<hr>
<p>软件	SH*IN    v13.0.2</p>
<p>包名     com.z*kko</p>
<hr>
<h1 id="抓包">抓包<a hidden class="anchor" aria-hidden="true" href="#抓包">#</a></h1>
<p>希音反爬的参数校验（armortoken、anti-in、smdeviceid）</p>
<p>针对armortoken这个参数</p>
<p><img alt="image-20250710111516928" loading="lazy" src="/zh/posts/tech/shenin/picture/image-20250710111516928.png"></p>
<h1 id="java层分析参数来源">java层分析参数来源<a hidden class="anchor" aria-hidden="true" href="#java层分析参数来源">#</a></h1>
<p>关键词搜索定位</p>
<p><img alt="image-20250710112024732" loading="lazy" src="/zh/posts/tech/shenin/picture/image-20250710112024732.png"></p>
<p><img alt="image-20250710113422498" loading="lazy" src="/zh/posts/tech/shenin/picture/image-20250710113422498.png"></p>
<p>这里GDA分析出来的逻辑明显有问题！（str=str1后没返回，返回一个exception你什么意思）</p>
<p>换jadx继续分析</p>
<p><img alt="image-20250710114332032" loading="lazy" src="/zh/posts/tech/shenin/picture/image-20250710114332032.png"></p>
<p>使用frida hook这里的SiArmorProxy.f中的str确实就是armortoken的来源</p>
<p><img alt="image-20250710113342648" loading="lazy" src="/zh/posts/tech/shenin/picture/image-20250710113342648.png"></p>
<p><img alt="image-20250710114730053" loading="lazy" src="/zh/posts/tech/shenin/picture/image-20250710114730053.png"></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">com.shein.armor.a.a
</span></span><span class="line"><span class="cl">参数（12, null)
</span></span></code></pre></td></tr></table>
</div>
</div><p><img alt="image-20250710114746449" loading="lazy" src="/zh/posts/tech/shenin/picture/image-20250710114746449.png"></p>
<p>使用ArtMethod中data段，来定位JNI函数的偏移和库</p>
<p>address :  0x71e2741cc0 offset:  <strong>0x77cc0</strong>  module :  <strong>libsi_armor.so</strong></p>
<h1 id="native层分析">native层分析<a hidden class="anchor" aria-hidden="true" href="#native层分析">#</a></h1>
<hr>
<p>so文件：libsi_armor.so</p>
<p>函数：public static native Object a(int i2, Object obj);</p>
<p>参数：a(12, null);</p>
<hr>
<h2 id="花指令去除">花指令去除<a hidden class="anchor" aria-hidden="true" href="#花指令去除">#</a></h2>
<p>进入到JNI方法偏移处，观察到有花指令</p>
<p><img alt="image-20250710120308932" loading="lazy" src="/zh/posts/tech/shenin/picture/image-20250710120308932.png"></p>
<p><img alt="image-20250710121910733" loading="lazy" src="/zh/posts/tech/shenin/picture/image-20250710121910733.png"></p>
<p>汇编指令分析</p>
<p><img alt="image-20250710123055489" loading="lazy" src="/zh/posts/tech/shenin/picture/image-20250710123055489.png"></p>
<p>其实最后跳转的地方就是 SUB X0, X0 #8 这段.text段的地址 + 0x44</p>
<p><img alt="image-20250710122706458" loading="lazy" src="/zh/posts/tech/shenin/picture/image-20250710122706458.png"></p>
<p>继续跟踪，跳转过去还有跳转</p>
<p><img alt="image-20250710162921778" loading="lazy" src="/zh/posts/tech/shenin/picture/image-20250710162921778.png"></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-txt" data-lang="txt"><span class="line"><span class="cl">#间接处理跳转地址的函数
</span></span><span class="line"><span class="cl">1、sub_77D4C  (makeX0NextAddrAdd8)
</span></span><span class="line"><span class="cl">将x0设为LR + 8
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">2、sub_77DC8  (makeX0NextAddr)
</span></span><span class="line"><span class="cl">x0 = LR
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">3、sub_77E38	(_makeX0NextAddr)
</span></span><span class="line"><span class="cl">x0 = LR
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">4、sub_77E88 (同1)
</span></span><span class="line"><span class="cl">x0 = LR + 0x8
</span></span><span class="line"><span class="cl">......
</span></span></code></pre></td></tr></table>
</div>
</div><p>这是根据上面的JNI函数跟踪先手动总结的，可能不完全</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-txt" data-lang="txt"><span class="line"><span class="cl">总结一下跳转的类型（是否以间接处理的函数地址来作为判断依据比较好？PASS，因为有些很多内容相同但函数名不同的）
</span></span><span class="line"><span class="cl">1、跳转地址为SUB X0, X0 #8 这段.text段的地址 + 0x44
</span></span><span class="line"><span class="cl">BL              sub_77D4C;
</span></span><span class="line"><span class="cl">SUB             X0, X0, #8 ;				00 20 00 D1
</span></span><span class="line"><span class="cl">ADD             X1, X0, #0x44 ; &#39;D&#39; ; 		01 10 01 91
</span></span><span class="line"><span class="cl">BR              X1   						20 00 1F D6
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">2、跳转地址为 ADD X0，X0,#8 的地址 + 0x10  （0x8 + 0x8）
</span></span><span class="line"><span class="cl">BL              sub_77D4C ;
</span></span><span class="line"><span class="cl">ADD             X0, X0, #8 ;			00 20 00 91
</span></span><span class="line"><span class="cl">BR              X0						00 00 1F D6
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">3、跳转地址为 MOV X9, X0 的地址 + 0x60
</span></span><span class="line"><span class="cl">BL              sub_77DC8 ; 
</span></span><span class="line"><span class="cl">MOV             X9, X0						E9 03 00 AA
</span></span><span class="line"><span class="cl">ADD             X9, X9, #0x60 ; &#39;`&#39; ; 		29 81 01 91
</span></span><span class="line"><span class="cl">BR              X9							20 01 1F D6
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">4、跳转地址为  MOV X2, X0  的地址 + 0x34
</span></span><span class="line"><span class="cl">BL              sub_77E38
</span></span><span class="line"><span class="cl">MOV             X2, X0  ;				E2 03 00 AA
</span></span><span class="line"><span class="cl">ADD             X2, X2, #0x34 ; 		42 D0 00 91
</span></span><span class="line"><span class="cl">BR              X2						40 00 1F D6
</span></span></code></pre></td></tr></table>
</div>
</div><p>只去除了部分，没有完全复原&hellip;&hellip;不过已经好看了一些</p>
<h2 id="unidbg动态分析">unidbg动态分析<a hidden class="anchor" aria-hidden="true" href="#unidbg动态分析">#</a></h2>
<p>构造调用a函数，之前分析快手的时候遇到过这种情况，其实还有初始化的函数没有调用</p>
<p><img alt="image-20250711113823431" loading="lazy" src="/zh/posts/tech/shenin/picture/image-20250711113823431.png"></p>
<p>回过头看java层确实需要调用initNative这个JNI函数</p>
<p><img alt="image-20250711114402509" loading="lazy" src="/zh/posts/tech/shenin/picture/image-20250711114402509.png"></p>
<p>漫长的补环境环节。。。利用frida去获得一些补环境的参数</p>
<p>（在分析java层的时候还是结合多个反编译工具一起看吧）</p>
<h3 id="部分补环境的记录">部分补环境的记录<a hidden class="anchor" aria-hidden="true" href="#部分补环境的记录">#</a></h3>
<p><img alt="image-20250712121144477" loading="lazy" src="/zh/posts/tech/shenin/picture/image-20250712121144477.png"></p>
<p><img alt="image-20250712121300368" loading="lazy" src="/zh/posts/tech/shenin/picture/image-20250712121300368.png"></p>
<p>这里com.shein.armor.a.b-&gt;b.overload(&lsquo;int&rsquo;, &ldquo;java.lang.Object&rdquo;)方法以frida获得的结果补充</p>
<p><img alt="image-20250712121238691" loading="lazy" src="/zh/posts/tech/shenin/picture/image-20250712121238691.png"></p>
<p>太好了没多少环境要补，成功模拟出a函数的返回值，也就是armortoken参数的值</p>
<p><img alt="image-20250712125310387" loading="lazy" src="/zh/posts/tech/shenin/picture/image-20250712125310387.png"></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-txt" data-lang="txt"><span class="line"><span class="cl">#armortoken 长度0xD7
</span></span><span class="line"><span class="cl">S2_3.3.5_Mv5PMqZ_w1zWL3VJfh7u-gwZRe_pO2RPE7C8JADr6EkDQR-iIzEEoqUdBgopOSWFkmorVqkVsuDzI81g26-G3lYExP6Sjmk8OyKbC7xVBJsUaa8WAZujzwBHDko-J_OtQ_PLc0XMuykK0896NckPX4VLjaEYumZ9BogyGhRW-zAosnFMUsq6SXsf6mFIDVEr_1752294024718
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">#参数构成
</span></span><span class="line"><span class="cl">固定标识
</span></span><span class="line"><span class="cl">SDK版本
</span></span><span class="line"><span class="cl">加密字段
</span></span><span class="line"><span class="cl">时间戳
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="具体分析">具体分析<a hidden class="anchor" aria-hidden="true" href="#具体分析">#</a></h3>
<p>根据unidbg输出日志JNIEnv-&gt;NewStringUTF    was called from RX@0x120804d4[libsi_armor.so]0x794d4</p>
<p>定位到0x794d4</p>
<p>在此处下断点，确实就是这个</p>
<p><img alt="image-20250712164959394" loading="lazy" src="/zh/posts/tech/shenin/picture/image-20250712164959394.png"></p>
<p><img alt="image-20250712171024593" loading="lazy" src="/zh/posts/tech/shenin/picture/image-20250712171024593.png"></p>
<p>老方法trace write 0x122dc1c0，开启溯源模式，定位到0x4993c，是memcpy函数</p>
<p><img alt="image-20250712171219172" loading="lazy" src="/zh/posts/tech/shenin/picture/image-20250712171219172.png"></p>
<p>从tracelog中找到源数据来源于0x122dc0e0<img alt="image-20250712171351802" loading="lazy" src="/zh/posts/tech/shenin/picture/image-20250712171351802.png"></p>
<p>还是从<code>0x4993c</code>的memcpy去分析，（<strong>在sub_49350中</strong>）</p>
<p>在0x49840的前后下断点，查看mx0的值，可以确定写入点就在这，将v57 + 时间戳拼接写入目标地址</p>
<p>根据前面的分析总体为（固定标识，SDK版本，加密字段，时间戳），现在称（固定标识，SDK版本，加密字段）为前缀</p>
<p>所以构成为 前缀 + 时间戳</p>
<p><img alt="image-20250712172756470" loading="lazy" src="/zh/posts/tech/shenin/picture/image-20250712172756470.png"></p>
<h4 id="前缀">前缀<a hidden class="anchor" aria-hidden="true" href="#前缀">#</a></h4>
<p><img alt="image-20250712174327630" loading="lazy" src="/zh/posts/tech/shenin/picture/image-20250712174327630.png"></p>
<p>根据tracelog可以确定是真条件下的值，这里是获取otherdata的地址，trace 0x122dc2a0 找到写入点</p>
<p><img alt="image-20250712174619572" loading="lazy" src="/zh/posts/tech/shenin/picture/image-20250712174619572.png"></p>
<p>0x49468</p>
<p><img alt="image-20250712175706911" loading="lazy" src="/zh/posts/tech/shenin/picture/image-20250712175706911.png"></p>
<p>在该vsnprint处下断点</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-txt" data-lang="txt"><span class="line"><span class="cl">v43 = 0xca 长度正确✔
</span></span><span class="line"><span class="cl">构造_ohterdata = &#34;S&#34; + &#34;2&#34; + a13 + v46
</span></span></code></pre></td></tr></table>
</div>
</div><h5 id="固定标识">固定标识<a hidden class="anchor" aria-hidden="true" href="#固定标识">#</a></h5>
<p>“S” + &ldquo;2&rdquo;</p>
<h5 id="sdk版本">sdk版本<a hidden class="anchor" aria-hidden="true" href="#sdk版本">#</a></h5>
<p>a13   0xe4fff449</p>
<p><img alt="image-20250712180032436" loading="lazy" src="/zh/posts/tech/shenin/picture/image-20250712180032436.png"></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-txt" data-lang="txt"><span class="line"><span class="cl">[18:05:56 245] Memory WRITE at 0xe4fff449, data size = 4, data value = 0x2e332e33, PC=RX@0x1204f9cc[libsi_armor.so]0x489cc, LR=RX@0x1204f520[libsi_armor.so]0x48520
</span></span></code></pre></td></tr></table>
</div>
</div><p>根据tracewrite定位到写入点（sub_486F4&mdash;&mdash;0x489cc）</p>
<p><img alt="image-20250712180749910" loading="lazy" src="/zh/posts/tech/shenin/picture/image-20250712180749910.png"></p>
<h5 id="加密字段">加密字段<a hidden class="anchor" aria-hidden="true" href="#加密字段">#</a></h5>
<p>0x122dc0e0   ，长度为0xb0</p>
<p><img alt="image-20250712180044422" loading="lazy" src="/zh/posts/tech/shenin/picture/image-20250712180044422.png"></p>
<p>定位到0x2ec98 是memove函数</p>
<p><img alt="image-20250712182553943" loading="lazy" src="/zh/posts/tech/shenin/picture/image-20250712182553943.png"></p>
<p><img alt="image-20250712181542219" loading="lazy" src="/zh/posts/tech/shenin/picture/image-20250712181542219.png"></p>
<p>memove是从0x122dc1c0赋值的数据，</p>
<p>观察到先在0x2ea28调用处赋值，再0x2ebd8处覆盖<strong>2f&mdash;&gt;5f; 2b&mdash;&gt;2d</strong></p>
<p><img alt="image-20250712215805294" loading="lazy" src="/zh/posts/tech/shenin/picture/image-20250712215805294.png"></p>
<p>0x122dc1c0定位到0x2EA24处是memcpy，在sub_3C8FC前后断点，可以发现，加密数据就是在<code>sub_3C8FC</code>中生成的</p>
<p><img alt="image-20250712220610848" loading="lazy" src="/zh/posts/tech/shenin/picture/image-20250712220610848.png"></p>
<h6 id="sub_3c8fcbase64">[sub_3C8FC]Base64<a hidden class="anchor" aria-hidden="true" href="#sub_3c8fcbase64">#</a></h6>
<p>一共两次调用该函数</p>
<p>**summary：**0x90是待base64编码的数据长度，a4参数是待编码数据</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-txt" data-lang="txt"><span class="line"><span class="cl">sub_3C8FC(__encryptData, v11, size, v17, v18);
</span></span><span class="line"><span class="cl">1、（0，0， size的指针，指针 ，0x90）
</span></span><span class="line"><span class="cl">	根据0x90是否为3的倍数，进行size = (4 * (0x90 / 3)) | 1; 
</span></span><span class="line"><span class="cl">2、（0x122dc0e0（指针）， 0xC1， size指针，指针（原始数据），0x90)
</span></span></code></pre></td></tr></table>
</div>
</div><p><img alt="image-20250712223243662" loading="lazy" src="/zh/posts/tech/shenin/picture/image-20250712223243662.png"></p>
<p>base64编码</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-txt" data-lang="txt"><span class="line"><span class="cl">#特征
</span></span><span class="line"><span class="cl">每次循环读取三字节，写入四字节
</span></span><span class="line"><span class="cl">使用右移 &gt;&gt;、与 &amp;、或 | 来组合 6-bit 的值
</span></span><span class="line"><span class="cl">所有位运算结果都被当作索引查一个数组
</span></span></code></pre></td></tr></table>
</div>
</div><p>将输入数组 <code>a4</code> 中的内容按 3 字节一组，编码成 4 字节的 Base64 字符，写入 <code>_reulst_ptr</code>。</p>
<p><img alt="image-20250712231011798" loading="lazy" src="/zh/posts/tech/shenin/picture/image-20250712231011798.png"></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-txt" data-lang="txt"><span class="line"><span class="cl">base64字符表
</span></span><span class="line"><span class="cl">byte_19188 = &#39;a-z&#39;,&#39;A-Z&#39;,0-9,+, &#34;/&#34;
</span></span></code></pre></td></tr></table>
</div>
</div><p>验证是标准的base64编码</p>
<p><img alt="image-20250712233038715" loading="lazy" src="/zh/posts/tech/shenin/picture/image-20250712233038715.png"></p>
<p>所以sub_3C8FC的a4就是<strong>base64前的数据</strong>，0x122eb0a0， 长度0x90</p>
<p><img alt="image-20250712233501854" loading="lazy" src="/zh/posts/tech/shenin/picture/image-20250712233501854.png"></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-txt" data-lang="txt"><span class="line"><span class="cl">0000: 32 FE 4F 32 A6 7F C3 5C D6 2F 75 49 7E 1E EE FA    2.O2...\./uI~...
</span></span><span class="line"><span class="cl">0010: 0C 19 45 EF E9 3B 64 4F 13 B0 BC 24 00 EB E8 49    ..E..;dO...$...I
</span></span><span class="line"><span class="cl">0020: 03 41 1F A2 23 31 04 A2 A5 1D 06 0A 29 39 25 85    .A..#1......)9%.
</span></span><span class="line"><span class="cl">0030: 92 6A 2B 56 A9 15 B2 E0 F3 23 CD 60 DB AF 86 DE    .j+V.....#.`....
</span></span><span class="line"><span class="cl">0040: 56 04 C4 FE 92 8E 69 3C 3B 22 9B 0B BC 55 04 9B    V.....i&lt;;&#34;...U..
</span></span><span class="line"><span class="cl">0050: 14 69 AF 16 01 9B A3 CF 00 47 0E 4A 3E 27 F3 AD    .i.......G.J&gt;&#39;..
</span></span><span class="line"><span class="cl">0060: 3F CB F6 EC 3D 41 AC 71 49 5E 6E E5 AA 31 BE 41    ?...=A.qI^n..1.A
</span></span><span class="line"><span class="cl">0070: 71 72 60 B2 9F 72 44 AF 6A FD 8F BF 0A B4 62 47    qr`..rD.j.....bG
</span></span><span class="line"><span class="cl">0080: A8 13 51 98 86 4F 0B EB AD 2E ED 84 CF 81 51 2B    ..Q..O........Q+
</span></span></code></pre></td></tr></table>
</div>
</div><p>0x2e8ec</p>
<h6 id="sub_39a40">[sub_39a40]<a hidden class="anchor" aria-hidden="true" href="#sub_39a40">#</a></h6>
<p>跳转到<strong>0x398D8</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-txt" data-lang="txt"><span class="line"><span class="cl">__int64 __fastcall sub_398D8(_BYTE *a1, __int64 a2, _OWORD *a3, unsigned int a4)
</span></span><span class="line"><span class="cl">a2，a3为0x122eb0a0待base64加密数据的指针
</span></span></code></pre></td></tr></table>
</div>
</div><p><img alt="image-20250712235420552" loading="lazy" src="/zh/posts/tech/shenin/picture/image-20250712235420552.png"></p>
<p>a2=a3=2+sdk版本+jni环境中的值com/shein/armor/a/b-b + android/os/Build-&gt;BRAND + android/os/Build-&gt;MODEL + 时间戳+？？？（这里的691724686）+ ？？？（c7cd4b）   且每个之间以^@拼接</p>
<p>最后以PKCS7填充</p>
<p><img alt="image-20250712235613430" loading="lazy" src="/zh/posts/tech/shenin/picture/image-20250712235613430.png"></p>
<p>​	是某种分组加密算法，继续分析</p>
<p><img alt="image-20250713000502514" loading="lazy" src="/zh/posts/tech/shenin/picture/image-20250713000502514.png"></p>
<p>dowhile 循环0x9次</p>
<p>每次处理a2中的（ a2 ~ a2 +7+8）16个字节的数据，每次循环结束后a2 + 16</p>
<p><img alt="image-20250713112247275" loading="lazy" src="/zh/posts/tech/shenin/picture/image-20250713112247275.png"></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">9x122eb0a0 ~ 0x122eb0af
</span></span><span class="line"><span class="cl">......
</span></span><span class="line"><span class="cl">0x122eb0a0 ~ 0x122eb120
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">a1[488] = a1[488] ^ a2
</span></span><span class="line"><span class="cl">a1[489] = a1[489] ^ (a2 + 1)
</span></span><span class="line"><span class="cl">a1[490] = a1[490] ^ (a2 + 2)
</span></span><span class="line"><span class="cl">......
</span></span><span class="line"><span class="cl">a1[503] = a1[503] ^ (a2 + 15)
</span></span></code></pre></td></tr></table>
</div>
</div><p>再进入 sub_3984C 函数，将结果位置的v7存在a3中</p>
<p><code>a1[488~503]</code> 是迭代状态</p>
<p><img alt="image-20250713124610768" loading="lazy" src="/zh/posts/tech/shenin/picture/image-20250713124610768.png"></p>
<p>根据tracelog可以看出，这里的v7也是16字节，a2和a3一开始是相同指针地址，所以这里v9后续取的也就是sub_3984C处理后的数据</p>
<p><img alt="image-20250713124643554" loading="lazy" src="/zh/posts/tech/shenin/picture/image-20250713124643554.png"></p>
<p>所以更加推断是AES的CBC模式，接下去去获取iv和key</p>
<h6 id="sub_3984c-核心">[sub_3984C] 核心<a hidden class="anchor" aria-hidden="true" href="#sub_3984c-核心">#</a></h6>
<p><img alt="image-20250713113006855" loading="lazy" src="/zh/posts/tech/shenin/picture/image-20250713113006855.png"></p>
<p>根据这几个表索引查到其实是TE表1-4，用于查找表优化</p>
<p><img alt="image-20250713113114888" loading="lazy" src="/zh/posts/tech/shenin/picture/image-20250713113114888.png"></p>
<p><img alt="image-20250713113121971" loading="lazy" src="/zh/posts/tech/shenin/picture/image-20250713113121971.png"></p>
<p>trace sub_394F4返回前 0xe4fff2d0L的内存，就是最后的密文</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-txt" data-lang="txt"><span class="line"><span class="cl">======================sub_394F4=================================
</span></span><span class="line"><span class="cl">0000: 32 5E 40 5E 33 2E 33 2E 35 5E 40 5E 31 64 30 35   2^@^3.3.5^@^1d05
</span></span><span class="line"><span class="cl">======================sub_394F4=================================
</span></span><span class="line"><span class="cl">0000: 57 9A 78 0A C5 4E A6 6C E7 1C 41 2D 4B 7A D6 CF   W.x..N.l..A-Kz..
</span></span><span class="line"><span class="cl">======================sub_394F4=================================
</span></span><span class="line"><span class="cl">0000: 39 2F 76 DF D1 0E 56 79 24 88 DA 40 39 8D DC 2A   9/v...Vy$..@9..*
</span></span><span class="line"><span class="cl">======================sub_394F4=================================
</span></span><span class="line"><span class="cl">0000: 65 79 7A C0 16 09 62 90 9C 24 67 68 4A 0E 16 BC   eyz...b..$ghJ...
</span></span><span class="line"><span class="cl">======================sub_394F4=================================
</span></span><span class="line"><span class="cl">0000: F3 5F 18 63 9F 74 D7 84 CB 47 FE 02 85 EF D8 B9   ._.c.t...G......
</span></span><span class="line"><span class="cl">======================sub_394F4=================================
</span></span><span class="line"><span class="cl">0000: 39 6B A3 92 F7 D0 29 62 75 47 E3 7E CF 75 32 CB   9k....)buG.~.u2.
</span></span><span class="line"><span class="cl">======================sub_394F4=================================
</span></span><span class="line"><span class="cl">0000: 4A 29 F1 27 36 AE 91 FC 38 7E 37 78 0B 17 C0 99   J).&#39;6...8~7x....
</span></span><span class="line"><span class="cl">======================sub_394F4=================================
</span></span><span class="line"><span class="cl">0000: BE 7C 1E 43 FC 8E 02 81 05 6D DA C1 A3 C1 E8 D2   .|.C.....m......
</span></span><span class="line"><span class="cl">======================sub_394F4=================================
</span></span><span class="line"><span class="cl">0000: 37 96 2C EC E2 89 2D 56 DD D5 6A 83 11 99 33 76   7.,...-V..j...3v
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">输入前
</span></span></code></pre></td></tr></table>
</div>
</div><p>输入后sub_394F4</p>
<p><img alt="image-20250713145650090" loading="lazy" src="/zh/posts/tech/shenin/picture/image-20250713145650090.png"></p>
<p>在0x398D8断点，</p>
<p>因为<code>a1[488..503]</code>：被不断 xor 操作，结合前面的分析，可以确定是 CBC 的IV =<code> 0000000000000000</code></p>
<p><img alt="image-20250713125430560" loading="lazy" src="/zh/posts/tech/shenin/picture/image-20250713125430560.png"></p>
<p>在9次循环下断点，每次的a1 + 488 第一次全0，后续都是上一次的结果，符合aesCBC</p>
<p>第一轮的才是初始iv</p>
<p><img alt="image-20250713151501711" loading="lazy" src="/zh/posts/tech/shenin/picture/image-20250713151501711.png"></p>
<p><img alt="image-20250713130442401" loading="lazy" src="/zh/posts/tech/shenin/picture/image-20250713130442401.png"></p>
<p>这几行表示用 <code>a1</code> 地址处的前 16 字节（即 <code>a1 + 0</code> 到 <code>a1 + 16</code>）分别和传入明文块（大端转小端后）做 XOR。</p>
<p>（a1其实包括了 key、iv、轮密钥这些数据）</p>
<p><del>密钥<code>Gibw1p_aX&amp;!0o+_G</code></del>		一开始以为是这个卡住了</p>
<p><img alt="image-20250713130311670" loading="lazy" src="/zh/posts/tech/shenin/picture/image-20250713130311670.png"></p>
<p>每四字节读取作为密钥为</p>
<p><code> wbiGa_p10!&amp;XG_+o</code></p>
<p><img alt="image-20250713160638668" loading="lazy" src="/zh/posts/tech/shenin/picture/image-20250713160638668.png"></p>
<p><img alt="image-20250713160723162" loading="lazy" src="/zh/posts/tech/shenin/picture/image-20250713160723162.png"></p>
<p><img alt="image-20250713160849959" loading="lazy" src="/zh/posts/tech/shenin/picture/image-20250713160849959.png"></p>
<p>成功恢复，iv和key正确</p>
<p><img alt="image-20250713161839145" loading="lazy" src="/zh/posts/tech/shenin/picture/image-20250713161839145.png"></p>
<h6 id="明文数据的来源">明文数据的来源<a hidden class="anchor" aria-hidden="true" href="#明文数据的来源">#</a></h6>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-txt" data-lang="txt"><span class="line"><span class="cl">#0x122eb000
</span></span><span class="line"><span class="cl">0000: 32 5E 40 5E 33 2E 33 2E 35 5E 40 5E 31 64 30 35    2^@^3.3.5^@^1d05
</span></span><span class="line"><span class="cl">0010: 65 64 37 38 63 31 65 30 31 33 34 64 35 64 38 35    ed78c1e0134d5d85
</span></span><span class="line"><span class="cl">0020: 35 36 33 30 38 35 32 36 37 38 66 64 39 66 34 63    5630852678fd9f4c
</span></span><span class="line"><span class="cl">0030: 66 38 65 62 35 38 66 32 39 39 61 62 63 37 33 39    f8eb58f299abc739
</span></span><span class="line"><span class="cl">0040: 61 35 33 35 36 61 65 64 38 64 33 62 5E 40 5E 67    a5356aed8d3b^@^g
</span></span><span class="line"><span class="cl">0050: 6F 6F 67 6C 65 5E 40 5E 4E 65 78 75 73 20 36 50    oogle^@^Nexus 6P
</span></span><span class="line"><span class="cl">0060: 5E 40 5E 31 37 35 32 33 39 34 33 37 31 35 32 30    ^@^1752394371520
</span></span><span class="line"><span class="cl">0070: 5E 40 5E 34 32 38 30 34 30 33 30 31 5E 40 5E 38    ^@^428040301^@^8
</span></span><span class="line"><span class="cl">0080: 36 61 34 64 31 0B 0B 0B 0B 0B 0B 0B 0B 0B 0B 0B    6a4d1...........
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">2+sdk版本+jni环境中的值com/shein/armor/a/b-b + android/os/Build-&gt;BRAND + android/os/Build-&gt;MODEL + 时间戳+？？？1（这里的691724686）+ ？？？2（c7cd4b）   且每个之间以^@拼接
</span></span></code></pre></td></tr></table>
</div>
</div><p>【1】随机数（以时间戳为种子生成）</p>
<p>0x48d60找到048D60处的memcpy</p>
<p><img alt="image-20250713182032130" loading="lazy" src="/zh/posts/tech/shenin/picture/image-20250713182032130.png"></p>
<p><img alt="image-20250713182209700" loading="lazy" src="/zh/posts/tech/shenin/picture/image-20250713182209700.png"></p>
<p>剩下三个参数由栈传递</p>
<p><img alt="image-20250713211612157" loading="lazy" src="/zh/posts/tech/shenin/picture/image-20250713211612157.png"></p>
<p><img alt="image-20250713212556119" loading="lazy" src="/zh/posts/tech/shenin/picture/image-20250713212556119.png"></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-txt" data-lang="txt"><span class="line"><span class="cl">%d	^@^	%s	^@^	%s	^@^ %s ^@^   %s ^@^ %s ^@^ %d
</span></span><span class="line"><span class="cl">2 		3.3.5	1d...   google    Nexus 6P   1752412831975     853602514
</span></span></code></pre></td></tr></table>
</div>
</div><p>拼接jni environment中的参数</p>
<p><img alt="image-20250713182940547" loading="lazy" src="/zh/posts/tech/shenin/picture/image-20250713182940547.png"></p>
<p><img alt="image-20250713212935842" loading="lazy" src="/zh/posts/tech/shenin/picture/image-20250713212935842.png"></p>
<p>这个参数就是以时间戳为种子生成的随机数</p>
<p>​		存储在0x122d6100中</p>
<p>【2】md5[-6:]</p>
<p>前面一共0x7C</p>
<p>这里添加0x405e32 &ldquo;^@^&rdquo;</p>
<p><img alt="image-20250713165232316" loading="lazy" src="/zh/posts/tech/shenin/picture/image-20250713165232316.png"></p>
<p><img alt="image-20250713165916021" loading="lazy" src="/zh/posts/tech/shenin/picture/image-20250713165916021.png"></p>
<p>在0x83764处的memove处下断点</p>
<p>LR=RX@0x120500d8[libsi_armor.so]0x490d8</p>
<p><img alt="image-20250713170317236" loading="lazy" src="/zh/posts/tech/shenin/picture/image-20250713170317236.png"></p>
<p>0xe4fff3b9   0x838b4   0x122d30aa   0x49014</p>
<p>在进入0x838b4   （sub_83814时，0x122d30aa   就已经有该值了 ） ，所以和 a2和a3有关</p>
<p>一开始没有trace到，是因为直接trace了0x122d30aa   -0x122d30aa   +0x6的范围，扩大范围0x36520</p>
<p><img alt="image-20250713215956043" loading="lazy" src="/zh/posts/tech/shenin/picture/image-20250713215956043.png"></p>
<p>sub_3639C对a1+1的地址进行hex编码得到最后段数据</p>
<p><img alt="image-20250713221558643" loading="lazy" src="/zh/posts/tech/shenin/picture/image-20250713221558643.png"></p>
<p>在sub_3AD9C断点，对比前后&amp;v18的结果 因为花指令取出不完整，采用对照trace的跳转地址</p>
<p><img alt="image-20250713222002644" loading="lazy" src="/zh/posts/tech/shenin/picture/image-20250713222002644.png"></p>
<p>最后进入 sub_3A1E4  （大量的位操作 (<code>&amp;</code>, <code>|</code>, <code>~</code>, <code>&gt;&gt;</code>) 大量固定的魔法数字 (Magic Numbers)，例如 <code>-389564586</code>, <code>606105819</code>, <code>-1044525330</code>, <code>-176418897</code>, <code>1200080426</code>, <code>-1473231341</code>），就是md5加密</p>
<p><img alt="image-20250713222625233" loading="lazy" src="/zh/posts/tech/shenin/picture/image-20250713222625233.png"></p>
<p>在线验证，是未魔改的md5</p>
<p><img alt="image-20250713175053342" loading="lazy" src="/zh/posts/tech/shenin/picture/image-20250713175053342.png"></p>
<p>2其实是对前面的数据进行md5后取后6位</p>
<p>过程中发现密钥是硬编码</p>
<p><img alt="image-20250713165154711" loading="lazy" src="/zh/posts/tech/shenin/picture/image-20250713165154711.png"></p>
<h6 id="覆盖">覆盖<a hidden class="anchor" aria-hidden="true" href="#覆盖">#</a></h6>
<p>在0x2ebfc处覆盖<strong>2f&mdash;&gt;5f; 2b&mdash;&gt;2d</strong></p>
<p><img alt="image-20250713223253532" loading="lazy" src="/zh/posts/tech/shenin/picture/image-20250713223253532.png"></p>
<p><img alt="image-20250713223219672" loading="lazy" src="/zh/posts/tech/shenin/picture/image-20250713223219672.png"></p>
<h4 id="时间戳">时间戳<a hidden class="anchor" aria-hidden="true" href="#时间戳">#</a></h4>
<p>通过<code>gettimeofday</code>函数获取时间戳加入到armortokenstr的末尾</p>
<h1 id="总结">总结<a hidden class="anchor" aria-hidden="true" href="#总结">#</a></h1>
<p><code>armortoken</code> 参数生成方式：</p>
<ul>
<li>
<p>固定标识 <code>&quot;S&quot;</code> + <code>&quot;2&quot;</code></p>
</li>
<li>
<p>SDK 版本号（例如 <code>3.3.5</code>）</p>
</li>
<li>
<p>密文数据：</p>
<p><code>com/shein/armor/a/b-b</code>的值、设备品牌（<code>android/os/Build-&gt;BRAND</code>）、设备型号（<code>android/os/Build-&gt;MODEL</code>）</p>
<p>、时间戳、一个以时间戳为种子生成的<strong>随机数</strong>、由前面数据以及^@^构成的数据进行 MD5 加密后截取<strong>后 6 位</strong>的值，并可能在末尾进行 <strong>PKCS7 填充</strong>。 构成<strong>明文数据</strong>，在使用<strong>AES-256 加密算法的 CBC 模式</strong>进行加密，然后将 <code>2f</code> (ASCII &lsquo;/&rsquo;) 替换为 <code>5f</code> (ASCII &lsquo;_&rsquo;)，将 <code>2b</code> (ASCII &lsquo;+&rsquo;) 替换为 <code>2d</code> (ASCII &lsquo;-&rsquo;)，再进行HEX编码，最后进行base64编码</p>
</li>
</ul>
<h1 id="额外知识点">额外知识点<a hidden class="anchor" aria-hidden="true" href="#额外知识点">#</a></h1>
<hr>
<p>补充一下一些内容</p>
<hr>
<ul>
<li></li>
</ul>
<p>unidbg中<code>callStaticJniMethod</code> 和 <code>Module.callFunction</code> 方式调用JNI函数的区别和优劣</p>
<p><strong><code>callStaticJniMethod</code> 通过 JNI 层调用 Java 方法</strong></p>
<p>​	通过模拟 Java 层调用 JNI 方法，是通过 DalvikVM 来模拟 Android Java 层代码执行，部会模拟 JNI 注册，参数转换，以及回调 Native 层。</p>
<p>​	逻辑性较完整，因为是模拟的从java层去调用，适合注册了native的方法</p>
<p><strong><code>module.callFunction</code> 直接调用 native 函数地址</strong></p>
<p>​	直接调用 SO 文件中某个函数的地址，跳过 Java 层、JNI 封装，直接进入 native 层执行函数代码。</p>
<p>​	直接调用特定函数，可用于定位、反调试、HOOK 点、内部逻辑执行。</p>
<ul>
<li></li>
</ul>
<p>Number number = module.callFunction()
这个 number 的意义是：</p>
<p>如果 native 函数返回的是一个整数（如 int 或 jint），你可以用 number.intValue()</p>
<p>如果函数返回一个对象（如 jstring 或其他 jobject），那么返回值是该对象在虚拟机中的 reference ID</p>
<ul>
<li></li>
</ul>
<p>安卓系统静态常量（用于部分环境补充）</p>
<table>
  <thead>
      <tr>
          <th>字段</th>
          <th>命令</th>
          <th>示例返回</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><code>Build.BRAND</code></td>
          <td><code>adb shell getprop ro.product.brand</code></td>
          <td><code>google</code></td>
      </tr>
      <tr>
          <td><code>Build.MODEL</code></td>
          <td><code>adb shell getprop ro.product.model</code></td>
          <td><code>MI 9</code></td>
      </tr>
      <tr>
          <td><code>Build.MANUFACTURER</code></td>
          <td><code>adb shell getprop ro.product.manufacturer</code></td>
          <td><code>Xiaomi</code></td>
      </tr>
      <tr>
          <td><code>Build.DEVICE</code></td>
          <td><code>adb shell getprop ro.product.device</code></td>
          <td><code>cepheus</code></td>
      </tr>
      <tr>
          <td><code>Build.FINGERPRINT</code></td>
          <td><code>adb shell getprop ro.build.fingerprint</code></td>
          <td><code>Xiaomi/cepheus/cepheus:10/QKQ1...</code></td>
      </tr>
      <tr>
          <td><code>Build.VERSION.SDK_INT</code></td>
          <td><code>adb shell getprop ro.build.version.sdk</code></td>
          <td><code>30</code></td>
      </tr>
      <tr>
          <td><code>Build.VERSION.RELEASE</code></td>
          <td><code>adb shell getprop ro.build.version.release</code></td>
          <td><code>11</code></td>
      </tr>
  </tbody>
</table>
<h1 id="参考资料">参考资料<a hidden class="anchor" aria-hidden="true" href="#参考资料">#</a></h1>
<p><a href="https://mp.weixin.qq.com/s/nvNCmXXAbstYZUkxDZ9ZnQ">https://mp.weixin.qq.com/s/nvNCmXXAbstYZUkxDZ9ZnQ</a></p>
<p><a href="https://www.cnblogs.com/kentle/p/15529251.html">https://www.cnblogs.com/kentle/p/15529251.html</a></p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://SimpsonGet.github.io/zh/tags/unidbg/">Unidbg</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="https://SimpsonGet.github.io/zh/posts/tech/vip/">
    <span class="title">« 上一页</span>
    <br>
    <span>【爬虫】唯品会APP逆向</span>
  </a>
  <a class="next" href="https://SimpsonGet.github.io/zh/posts/read/owasp/">
    <span class="title">下一页 »</span>
    <br>
    <span>Owasp Tpo 10 学习</span>
  </a>
</nav>

  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="https://SimpsonGet.github.io/zh/">Simpson&#39;s Blog</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = '复制';

        function copyingDone() {
            copybutton.innerHTML = '已复制！';
            setTimeout(() => {
                copybutton.innerHTML = '复制';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
