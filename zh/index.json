[{"content":" 本文仅作为个人技术学习与研究的记录，旨在分享逆向分析的思路和方法，不涉及也不鼓励任何形式的商业破解、盗版传播或非法用途。文中所有示例与操作均出于技术探讨目的，且涉及的关键信息已进行脱敏处理，不会影响或泄露实际软件的商业利益。\n如有内容存在侵权或不当之处，请联系我，我将第一时间删除或修正。\n问题 如图，早上打开办公软件，收到了新设置不让截图的通知\n打开app任意界面截图的时候，提示无法截图\n分析 安卓提供app设置截图权限的api有\n1 2 3 4 5 6 7 1、setFlags(flags, mask) 该方法属于 Window（通常通过 getWindow() 获取），调用 setFlags(flags, mask) 会先清除 mask 指定的位，然后设置 flags 指定的位。 常用于：设置或清除窗口属性，例如禁止截图、控制状态栏样式、窗口尺寸格式等。通过 getWindow().setFlags(WindowManager.LayoutParams.FLAG_SECURE, WindowManager.LayoutParams.FLAG_SECURE) 可彻底开启 不允许截图 功能。 2、addFlags(flags) Window 的方法，用于向当前已有的窗口标志中“追加”指定的标志，即在原有 flags 基础上通过位或 (|) 增加新的标志。 常用于：使用addFlags(flags)中调用setFlags 当flag设置为0x2000的时候，即为设置了不允许截图\n对上述api hook,定位到 设置的位置\n根据调用栈推测，应该是 企业设置了 以后，后端会将某个标志数据一起传给app，当app登录该企业账号的时候就会更新设置\n跟踪分析可以发现allPermissionData 里面就包含了对 是否允许截图 的设置标志\n设置的条件是根据这个json文件中对MOBILE_SCREEN_PROTECT的设置\n它是使用 android.os.Handler 发送的这个json信息，hook相关发送的api ,定位到写入的地方\n1 sendMessageAtTime(Message msg, long uptimeMillis) 对同步抓包中的数据包识别，根据代码中的**\u0026ldquo;init\u0026rdquo;、”api\u0026quot;**等关键字猜测大概率是这个传入设置\n解决方案 绕过很简单，对setflags 的hook修改返回即可\n1 2 3 var FLAG_SECURE = 0x2000; console.log(\u0026#34; \u0026gt;\u0026gt;\u0026gt; Removing FLAG_SECURE so screenshot is allowed \u0026lt;\u0026lt;\u0026lt;\u0026#34;); flags = flags \u0026amp; ~FLAG_SECURE; 结果：正常截图\n目前就是实时的用frida测试了方案，如果需要长期融入日常使用可以转换成xposed脚本，结合lspatch也可以在无root的情况下使用。\n对于其他禁止截图的APP本质上采用一样的方法。应该都可以绕过。因为手机截图毕竟都得用android本身的api，那么禁止的手段也是与其相关。\n","permalink":"https://SimpsonGet.github.io/zh/posts/tech/feishu/","summary":"使用frida绕过APP禁止截图的设置","title":"[破解]飞book_禁止截图"},{"content":"内存布局检测 ​\tunidbg的内存布局:\n​\t栈和堆的空间是在memory.java中设置的， 栈设置一个高地址为栈底， 向低地址延伸作为栈空间。 堆设置一个低地址， 向高地址延伸作为堆空间\n​\t但是在真机上，堆栈地址更高，远高于unidbg设置的（当然unidbg可以设置）\n两者比较，unidbg的堆栈地址是固定的，每次运行他都是基于memory.java中设置的去执行，因此不管运行几次都是固定的空间，这可以作为监测点。 jni检测 调用检测 ​\tunidbg代理了整个java层，将jni桥函数位于0xfffe0000L - 0xffff0000L， 每个跳板函数只有8个字节（中断指令、返回指令）\n​\t在真机环境下，相邻的jni桥函数之间像个至少几十个字节\n方法检测 ​\tunidbg 处理jni的默认策略：会将在调用所有的类/方法时，默认成功获取。如 findclass、getmethodid等函数。\n​\t把这个作为检测点的话，可以在app代码中添加，主动去找不存在的类，判断是否找到。 但是这个作为日志输出时比较明显，那么可以去寻找系统类，但是将其中的字母修改成近似字符或者空格 等隐蔽性更好（如在getmethodid的时候，修改方法签名）\n​\t应对手段：unidbg提供了 addNotFoundClass 函数，主动告知unidbg目标类不在代码中， aceeptMethod 和 acceptFiled（这两个需要重写方法，去抛出异常）\n方法ID ​\tmethodId，在真机中是一个指向ArtMethod的结构体指针，而在unidbg，是对方法签名的一个hash值。 这里的对抗方法可以主动去构造计算方法的签名并计算哈希，对比methodid\n文件描述符 ​\t在真机设备中，使用open、openat等处理文件的函数，打开文件会返回一个文件描述符。是从0开始向正增长的。\n​\t0、1、2对应的分别是标准输入、输出、错误这三个文件描述符\n​\t在真机中基本上都有十几个文件交互，那么文件描述符都在20+\n​\t但是在undibg中只模拟了so，只有012这三个，那么后面交互的文件基本上都小于20\nuname指令 ​\tuname指令可以返回系统信息、版本、架构等\n​\tunidbg设计的时候主机信息设置的是**\u0026ldquo;1.0.0.-unidbg\u0026rdquo;**\n​\t这里的检测点是可以主动执行uname函数，对比是否存在关键字 “unidbg\u0026quot;\n​\t当然，对抗手段也很简单，直接修改unidbg代码中这部分的返回值为真机的返回值\n运行时间检测 ​\tunidbg的模拟执行效率远大于手机的执行时间，可以比对这些时间。但是容易误报一些老旧版本的手机。\n","permalink":"https://SimpsonGet.github.io/zh/posts/tech/unidbg_detect/","summary":"unidbg 部分 检测-对抗手段","title":"Unidbg 检测"},{"content":" 包名：Y29tLm1vYmlsZS5sZWdlbmRz==\n我在分析某一个游戏app的时候，需要抓它的包，但是我在使用r0capture或者自实现的socket Hook时，只hook到一两个包，这完全是不正常的。\n查看一下进程，发现有子进程的，显而易见，具体的实现其实都在第二个里面。\n这里可以理解成像是热更新等，看是运行的是A.dex，其实动态加载运行了B.dex，很多游戏都是这样子的写法，之后遇到了发现不正常的hook结果的话，就可以想到这一点。（新姿势+1）\n这里引入一下frida Child Gating机制\nChild Gating 简单来说，这是frida的一个机制，它主要的应用场景是在想要hook的操作在子进程中时。\n在主进程进行子进程创建的操作时，将这个操作挂起，然后通过回调注入frida的脚本，再恢复。\n用法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #对父进程的附加，和启用child_gating功能 session = device.attach(pid) session.enable_child_gating() #接收子进程创建的通知，以及创建回调函数 device.on(\u0026#34;child-added\u0026#34;, on_child_added) device.on(\u0026#34;child-removed\u0026#34;, on_child_removed) def on_child_added(child): # Attach to the child process session = device.attach(child.pid) # Enable child gating for this process too (if needed) session.enable_child_gating() # Create and load script script = session.create_script(...) script.load() # Resume the child process device.resume(child.pid) 但是呢，我一开始没注意，在写好测试以后才发现，child.pid一直没有识别到ps -ef一样的子进程（有一些其他的）。\n这是因为：child_gating 只能识别由已开启 enable_child_gating 的进程直接 fork() 出来的子进程，即 ppid 必须是父进程本身。但在这个场景中，虽然进程 A 启动了进程 B，但 B 实际上是通过 A 调用系统服务请求 zygote 进行 fork 的，因此 B 的 ppid 是 zygote 而不是 A，child_gating 无法生效。\n在 Android 中，App 启动通常并不是由已有 App 自行 fork 子进程完成，而是通过 Binder 调用 system_server → activity_manager → zygote fork。这种架构使得即便进程 A 触发了进程 B 的创建，它们之间也不是父子进程关系。\nwhile 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 # -*- coding: utf-8 -*- from __future__ import print_function import threading import time import frida from frida_tools.application import Reactor import subprocess import sys package = \u0026#34;com.m***e.l****s\u0026#34; child_gating = package + \u0026#34;:U**tyK**s**\u0026#34; script_path = \u0026#34;*******\\hook_socket.js\u0026#34; log_file = \u0026#39;******\\\\frida_console2.log\u0026#39; class Application(object): def __init__(self): self._stop_requested = threading.Event() self._reactor = Reactor(run_until_return=lambda reactor: self._stop_requested.wait()) self._device = frida.get_usb_device() self._sessions = set() def run(self): self._reactor.schedule(lambda: self._start()) self._reactor.run() def _start(self): self._device = frida.get_usb_device() #先启动父进程 print(\u0026#34;✔ spawn \u0026#34; + package) pid = self._device.spawn([package]) print(f\u0026#34;✔ resume(pid={pid})\u0026#34;) self._device.resume(pid) print(\u0026#34;⏳ 等待子进程...\u0026#34;) target_pid = None while True: result = subprocess.run([\u0026#34;adb\u0026#34;, \u0026#34;shell\u0026#34;, \u0026#34;ps\u0026#34;, \u0026#34;-ef\u0026#34;], stdout=subprocess.PIPE, text=True) lines = [line for line in result.stdout.splitlines() if package in line] if len(lines) \u0026gt;= 2: target_pid = lines[1].split()[1] # 第二个匹配行，取 PID print(f\u0026#34;✅ 找到目标子进程 PID: {target_pid}\u0026#34;) break else: print(\u0026#34;🔍 未找到第二个进程，继续等待...\u0026#34;) time.sleep(1) self._instrument(int(target_pid)) def _instrument(self, target_pid): cmd = [ \u0026#34;frida\u0026#34;, \u0026#34;-U\u0026#34;, \u0026#34;-p\u0026#34;, str(target_pid), \u0026#34;-l\u0026#34;, script_path, \u0026#34;-o\u0026#34;, log_file ] # cmd = [ # \u0026#34;python\u0026#34;, # \u0026#34;D:\\\\tools\\\\r0capture\\\\r0capture.py\u0026#34;, # \u0026#34;-U\u0026#34;, # str(target_pid) # ] # 启动并附加到进程 subprocess.run(cmd) def _on_detached(self, pid, session, reason): print(f\u0026#34;⚡ detached: pid={pid}, reason=\u0026#39;{reason}\u0026#39;\u0026#34;) self._sessions.remove(session) self._reactor.schedule(self._stop_if_idle, delay=0.5) app = Application() app.run() 最后就是采用的这种循环查看进程，直到知道第二个进程再使用-p执行frida脚本\n","permalink":"https://SimpsonGet.github.io/zh/posts/tech/childgating/","summary":"frida hook不到？不应该啊？！尝试一下这个！","title":"Frida Hook 子进程"},{"content":" com.shizhuang.duapp\n5.71.0\n总体来说，加密算法是常规的，这次样本的学习的地方就是对VMP壳的处理手段（直接对jni函数的trace、hook绕过壳和混淆。更深入的vmp还需继续学习） 搜索部分还有图形验证码，数据也是加密的\n先看看这个热榜的接口，和那些有共同的new sign\n直接python，可以复现\nheader的参数都与 newsign有关，而获取每天的热榜肯定与时间戳是有关系的，所以现在分析newsign的生成，后续就可以获取每天的热榜\nnewSign分析 根据热榜的报文是GET所以这里定位的是上图中的第一个条\n过frida检测 得物有frida检测，开启frida软件直接闪退了\n看了一下也是那一套检测，直接hook dlopen 将创建pthread_create的函数置空\nnewSign一致，验证上面定位正确\njava分析 总结： 以loginToken、platform、timestamp、uuid、v以及对应的值拼接为字符串，通过jni函数IL得到结果，在进行md5，为最终结果 根据hook的结果x0.h()参数str如下：\n？但是根据代码中的逻辑，这里应该是为空的 (应该是热修复替换了)\n1 76dd135c07ed833c********9ca6b5d85f471b44a42bb382bbaad346f37b0d3193b22470362bf4b267f4f8f30b88b0b1d69dc1f8******1508292aa7869f1793|2622023754|1753003762|33f8c808aab40b67590da0565ab9115096841217|1-0|d41d8cd903d0336c x0.h函数如下\n核心逻辑再JNI函数 IL中\ndex vmp的特征\n1 2 3 4 第一个参数，其实就是代表了当前这个函数，用这个数字来索引已经被虚拟化的代码来执行。 使用了大量的jni函数而且，没有什么别的函数 写成通用的c成调用任何java方法的功能 具有常量函数列表 将jni函数返回值进行md5加密，就获得了最终的newSign的值\n经验证，k（）是常规md5\n1 str=loginToken76dd135c07ed833c*********addba567339ca6b5d85f471b44a42bb382bbaad346f37b0d3193b22470362bf4b267f4f8f30b88b******5f7dcec6f1508292aa7869f1793|2622023754|1753003762|33f8c808aab40b67590da0565ab9115096841217|1-0|d41d**cplatformandroidtimestamp1753082568871uuide31c***77*1061v5.71.0 获得context的类型为com.shizhuang.duapp.modules.app.DuApplication\n将hook到的数据和报文数据对比，如下这些值是相关的，logintoken需要看来源\n函数参数 报文数据 值 loginToken duloginToken 76dd135c07？？？5f471b44a42bb382bbaad346f3？？？b88b0b1d69dc1f8f73115f7dcec6f1508292aa7869f1793 timestamp timestamp 175308256887 platform duplatform android v duv 5.71.0 源数据 logintoken logintoken 是 传入的str，按理来说java层分析到是空的，但是实际不是也不可能是空的\n大概率是进入了热修复框架中替换了str\nuuid 使用美团的热修复框架\n不过这里多次测试都是固定值，就不继续看了\nnative lib: libGameVMP.so\nmethod_name:IL\noffset: 0xdac0\n先分析IL函数\nso文件修复 so文件应该被加密了，需要从内存dump，+修复\n在本机上\nso_base = 0x741ac05000\nso_size = 0x77000\n用sofixer修复\nnewway frida-dump\n这个工具整合了前面的人工一步步的步骤\nIL函数分析 1 2 3 public static String doWork(Object obj, String str) { return (String) NCall.IL(new Object[]{362, obj, str}); } 参数是由三部分构成的，obj为context\n针对VMP壳，需要获得JNI函数在内存的地址去分析？？？\n虚假控制流的 ollvm， 这里x，y这些全局变量就用作不透明谓词，对于这种需要trace找到真实路径并分析\n定参分析 固定参数主动调用，方便后续分析\n因为最终的结果native还是得通过jstring的形式返回，那么去hook相关的jni接口去定位它，这样做可以减少vmp壳和混淆的干扰\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 #相关jstring处理函数 jstring (*NewString)(JNIEnv*, const jchar*, jsize); jsize (*GetStringLength)(JNIEnv*, jstring); const jchar* (*GetStringChars)(JNIEnv*, jstring, jboolean*); void (*ReleaseStringChars)(JNIEnv*, jstring, const jchar*); jstring (*NewStringUTF)(JNIEnv*, const char*); jsize (*GetStringUTFLength)(JNIEnv*, jstring); /* JNI spec says this returns const jbyte*, but that\u0026#39;s inconsistent */ const char* (*GetStringUTFChars)(JNIEnv*, jstring, jboolean*); void (*ReleaseStringUTFChars)(JNIEnv*, jstring, const char*); jsize (*GetArrayLength)(JNIEnv*, jarray); jobjectArray (*NewObjectArray)(JNIEnv*, jsize, jclass, jobject); jobject (*GetObjectArrayElement)(JNIEnv*, jobjectArray, jsize); void (*SetObjectArrayElement)(JNIEnv*, jobjectArray, jsize, jobject); 在 libdewuhelper.so!encode+0x138!+0x185c 调用了NewStringUTF方法构建了字符串\nnative-2 lib:libdewuhelper\noffset:0x185c\nmethodname:encode\n同上述native中一样dump+修复，找到调用位置\nhook encode函数\n1 2 3 a3就是java输入的object中的str a4是位置01组成的字符串 “010110100010001010010010000011000111001011101010101000101110111010011010101101101010001000101100010110100010001010011010110011001111001011100010101000100100110010110010100010101011110010111100” a4是给getvalue用的？因为一个参数\n这个是将 8 字节压缩成一个字符，使用了一种非对称加权累加混淆算法。类似于自定义 base256 编码（非标准），并在结果上加 48。 __int64 __fastcall getValue(const char *a1)\ngetvalue指向0x160C处的getValue，尝试hook\n密钥就是d2*****78a61吗？？（因为中间没有其他操作，直接hook 下面这个aes的参数获取参数一样）\n是常规aes吗？？？ hook这个位置验证一下（是的）\n直接将v11，value通过cyberchef验证是不对的~~（魔改过？）~~\n最后进行了base64编码\naes分析 平坦化混淆的算法\n将参数处理后最后调用的是AES128_ECB_encrypt\n直接hookAES128_ECB_encrypt\n那其实这里的分析没有意义，直接hook最初的j_xxx，得到的返回值就是了，因为它本身也就是原始aes\n参数分析 1 v18 = (char *)j_AES_128_ECB_PKCS5Padding_Encrypt(v11, Value); [v11]\n就是java传入的str\n[value]\n密钥变相硬编码，虽然是通过getvalue得到的，但是传入的str是一样的\n请求还原 根据前面的分析，在请求得物热榜的时候，报文中只有一下四个值和sign相关\n这些是必要头\n成功还原\n更改参数生成后成功拉去求响应\n参考 https://so.csdn.net/so/search?q=libgamevmp\u0026t=blog\u0026u=linchaolong\nhttps://mp.weixin.qq.com/s/x6xIZ3cQ8fsVRpWORC45HA\n","permalink":"https://SimpsonGet.github.io/zh/posts/tech/du/","summary":"第一次真实遇到VMP壳，学习一些逆向手段","title":"【VMP初探】某电商sign值分析"},{"content":" 软件：唯品会\n包名：com.achievo.vipshop\n版本 9.42.8\n分析参数：authorization 删除了authorization 请求头，使用python复现报文的结果\n当把搜索参数“衣服” 改为”裤子“后就不能了， 应该是authorization是根据post内的一些值生成的，似乎是所有值（结果证明是对的）\njava层 直接关键字搜索就找了，省的去hook hash或者header\ncom.achievo.vipshop.commons.api.middleware.api.refector-process\ntreeMap 作为post的参数\n这里是采用的java反射调用\nhook反射函数，找到真实类（代码往下翻也是有的）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 function hook_reflect(){ Java.perform(function () { const Method = Java.use(\u0026#39;java.lang.reflect.Method\u0026#39;); Method.invoke.implementation = function (obj, args) { const methodName = this.getName(); if (methodName === \u0026#39;gs\u0026#39;) { console.log(\u0026#34;\\n[+] 捕获到对 \u0026#39;gs\u0026#39; 方法的反射调用！\u0026#34;); const className = obj.getClass().getName(); console.log(\u0026#34; |-- 真实类名: \u0026#34; + className); console.log(\u0026#34; |-- 方法签名: \u0026#34; + this.toString()); console.log(\u0026#34; |-- 调用堆栈:\u0026#34;); const stackTrace = Java.use(\u0026#34;android.util.Log\u0026#34;).getStackTraceString(Java.use(\u0026#34;java.lang.Throwable\u0026#34;).$new()); console.log(stackTrace); } return this.invoke(obj, args); }; }); } 定位到了是如下函数\n1 public static java.lang.String com.vip.vcsp.KeyInfo.gs(android.content.Context,java.util.Map,java.lang.String,boolean) 继续往下看发现是native的函数\n对该函数hook验证确定是该干函数\n最终在java层定位到jni函数 so文件为Keyinfo， metho_name = gsNav\njni函数的各个参数 a3和a4 固定 1 2 3 private static native String gsNav(Context context, Map\u0026lt;String, String\u0026gt; map, String str, boolean z10); 多次执行str= “425d8d985da3022ce5fd670765b30257” 固定 flase\t固定 native层 so：libKeyinfo.so\nmethod: gsNav\noffset: 0xf1edc\n使用artmethod的特征data字段来定位偏移（好吧其实不用，它是静态注册的）\ngetByteHash函数的作用是：计算给定a3数据缓冲区的 SHA1 哈希值，并将结果格式化为一个40个字符的小写十六进制字符串。\n即计算a3的hash值（使用SHA1）\n分析各个参数 1 _result = (const char *)getByteHash(a1, a2, v73, v58, \u0026amp;v89, 256LL); 【v73】待哈希的数据 v73 = “aee4c425dbb2288b80c71347cc37d04b ” + java层传入的第三个参数str + 前面两个数据以固定方式拼接map中的数据的hash值 由 src + v57\nsrc Utils_gsigds ：将有垃圾数据的字符串修正\nsrc = aee4c425dbb2288b80c71347cc37d04b + java层传入的第三个参数str\nv57 1 ByteHash = getByteHash(a1, a2, v19, (unsigned int)v17, \u0026amp;v89, 256LL); v57是v19（_src）的hash值\nv17是v19的长度，v89是输出缓冲区\n这段代码的意思是 将map中的数据提取出来拼接成url中的形式\nv19的值如下\n将上面的src + 键值对的key + \u0026ldquo;=\u0026rdquo; + 键值对的value + “\u0026amp;” + \u0026hellip;\u0026hellip;\nhook这个 getByteHash\n最后v73就是 _src的哈希是（使用SHA1计算）\n因此是原始的SHA1算法\n【v58】待哈希数据的长度 同理，v58是v73的长度\n将v73的值hash 得到最后的api _sign python爬虫还原 authorization算法部分的代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 import hashlib def getByteHash(originData): sha1_obj = hashlib.sha1() sha1_obj.update(originData.encode(\u0026#34;utf-8\u0026#34;)) return sha1_obj.hexdigest() def get_api_sign(post_data): str = \u0026#34;aee4c425dbb2288b80c71347cc37d04b\u0026amp;425d8d985da3022ce5fd670765b30257\u0026#34; str1 = str api_sign = \u0026#34;\u0026#34; flag = True #第一个字典不添加\u0026#34;\u0026amp;\u0026#34; #原始参数_1准备 for key, value in post_data.items(): #根据逆向的结果构造， = \u0026amp; if flag: tmp = key + \u0026#34;=\u0026#34; + value flag = False else: tmp = \u0026#34;\u0026amp;\u0026#34; + key + \u0026#34;=\u0026#34; + value str1 += tmp tmp2 = getByteHash(str1) #原始参数_2准备 str2 = str + tmp2 api_sign = getByteHash(str2) return \u0026#34;OAuth api_sign=\u0026#34; + api_sign def main(): data = otherdata data[\u0026#34;keyword\u0026#34;] = \u0026#34;书包\u0026#34;\t#自定义 api_sign = get_api_sign(data) headers = unSome_headers headers[\u0026#34;authorization\u0026#34;] = api_sign # 发送请求 url = \u0026#34;https://mapi.appvipshop.com/vips-mobile/rest/shopping/search/product/list/v1\u0026#34; response = requests.post(url, headers=headers, data=data) # 输出响应 print(\u0026#34;Status Code:\u0026#34;, response.status_code) print(\u0026#34;Response Body:\u0026#34;, response.text) 成功复原，可自定义搜索项进行爬虫，再结合正则表达、爬虫框架等，即可获取多款商品的价格等\n总结 authorization = “aee4c425dbb2288b80c71347cc37d04b ” +\u0026quot;\u0026amp;\u0026quot; + \u0026ldquo;425d8d985da3022ce5fd670765b30257\u0026rdquo; + 前面两个数据以固定方式拼接map中的数据的hash值\n即第一次对数据哈希，第二次对部分数据+哈希进行哈希\n","permalink":"https://SimpsonGet.github.io/zh/posts/tech/vip/","summary":"逆向反爬参数的生成策略，并还原","title":"【爬虫】唯品会APP逆向"},{"content":"着手该app逆向分析是因为看到wx公众号Frida and So的一篇文章，该公众号文章一如既往的言简意赅，因此尝试分析最新版本并补充细节。（如侵立删！）\n软件\tSH*IN v13.0.2\n包名 com.z*kko\n抓包 希音反爬的参数校验（armortoken、anti-in、smdeviceid）\n针对armortoken这个参数\njava层分析参数来源 关键词搜索定位\n这里GDA分析出来的逻辑明显有问题！（str=str1后没返回，返回一个exception你什么意思）\n换jadx继续分析\n使用frida hook这里的SiArmorProxy.f中的str确实就是armortoken的来源\n1 2 com.shein.armor.a.a 参数（12, null) 使用ArtMethod中data段，来定位JNI函数的偏移和库\naddress : 0x71e2741cc0 offset: 0x77cc0 module : libsi_armor.so\nnative层分析 so文件：libsi_armor.so\n函数：public static native Object a(int i2, Object obj);\n参数：a(12, null);\n花指令去除 进入到JNI方法偏移处，观察到有花指令\n汇编指令分析\n其实最后跳转的地方就是 SUB X0, X0 #8 这段.text段的地址 + 0x44\n继续跟踪，跳转过去还有跳转\n1 2 3 4 5 6 7 8 9 10 11 12 13 #间接处理跳转地址的函数 1、sub_77D4C (makeX0NextAddrAdd8) 将x0设为LR + 8 2、sub_77DC8 (makeX0NextAddr) x0 = LR 3、sub_77E38\t(_makeX0NextAddr) x0 = LR 4、sub_77E88 (同1) x0 = LR + 0x8 ...... 这是根据上面的JNI函数跟踪先手动总结的，可能不完全\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 总结一下跳转的类型（是否以间接处理的函数地址来作为判断依据比较好？PASS，因为有些很多内容相同但函数名不同的） 1、跳转地址为SUB X0, X0 #8 这段.text段的地址 + 0x44 BL sub_77D4C; SUB X0, X0, #8 ;\t00 20 00 D1 ADD X1, X0, #0x44 ; \u0026#39;D\u0026#39; ; 01 10 01 91 BR X1 20 00 1F D6 2、跳转地址为 ADD X0，X0,#8 的地址 + 0x10 （0x8 + 0x8） BL sub_77D4C ; ADD X0, X0, #8 ;\t00 20 00 91 BR X0\t00 00 1F D6 3、跳转地址为 MOV X9, X0 的地址 + 0x60 BL sub_77DC8 ; MOV X9, X0\tE9 03 00 AA ADD X9, X9, #0x60 ; \u0026#39;`\u0026#39; ; 29 81 01 91 BR X9\t20 01 1F D6 4、跳转地址为 MOV X2, X0 的地址 + 0x34 BL sub_77E38 MOV X2, X0 ;\tE2 03 00 AA ADD X2, X2, #0x34 ; 42 D0 00 91 BR X2\t40 00 1F D6 只去除了部分，没有完全复原\u0026hellip;\u0026hellip;不过已经好看了一些\nunidbg动态分析 构造调用a函数，之前分析快手的时候遇到过这种情况，其实还有初始化的函数没有调用\n回过头看java层确实需要调用initNative这个JNI函数\n漫长的补环境环节。。。利用frida去获得一些补环境的参数\n（在分析java层的时候还是结合多个反编译工具一起看吧）\n部分补环境的记录 这里com.shein.armor.a.b-\u0026gt;b.overload(\u0026lsquo;int\u0026rsquo;, \u0026ldquo;java.lang.Object\u0026rdquo;)方法以frida获得的结果补充\n太好了没多少环境要补，成功模拟出a函数的返回值，也就是armortoken参数的值\n1 2 3 4 5 6 7 8 #armortoken 长度0xD7 S2_3.3.5_Mv5PMqZ_w1zWL3VJfh7u-gwZRe_pO2RPE7C8JADr6EkDQR-iIzEEoqUdBgopOSWFkmorVqkVsuDzI81g26-G3lYExP6Sjmk8OyKbC7xVBJsUaa8WAZujzwBHDko-J_OtQ_PLc0XMuykK0896NckPX4VLjaEYumZ9BogyGhRW-zAosnFMUsq6SXsf6mFIDVEr_1752294024718 #参数构成 固定标识 SDK版本 加密字段 时间戳 具体分析 根据unidbg输出日志JNIEnv-\u0026gt;NewStringUTF was called from RX@0x120804d4[libsi_armor.so]0x794d4\n定位到0x794d4\n在此处下断点，确实就是这个\n老方法trace write 0x122dc1c0，开启溯源模式，定位到0x4993c，是memcpy函数\n从tracelog中找到源数据来源于0x122dc0e0\n还是从0x4993c的memcpy去分析，（在sub_49350中）\n在0x49840的前后下断点，查看mx0的值，可以确定写入点就在这，将v57 + 时间戳拼接写入目标地址\n根据前面的分析总体为（固定标识，SDK版本，加密字段，时间戳），现在称（固定标识，SDK版本，加密字段）为前缀\n所以构成为 前缀 + 时间戳\n前缀 根据tracelog可以确定是真条件下的值，这里是获取otherdata的地址，trace 0x122dc2a0 找到写入点\n0x49468\n在该vsnprint处下断点\n1 2 v43 = 0xca 长度正确✔ 构造_ohterdata = \u0026#34;S\u0026#34; + \u0026#34;2\u0026#34; + a13 + v46 固定标识 “S” + \u0026ldquo;2\u0026rdquo;\nsdk版本 a13 0xe4fff449\n1 [18:05:56 245] Memory WRITE at 0xe4fff449, data size = 4, data value = 0x2e332e33, PC=RX@0x1204f9cc[libsi_armor.so]0x489cc, LR=RX@0x1204f520[libsi_armor.so]0x48520 根据tracewrite定位到写入点（sub_486F4\u0026mdash;\u0026mdash;0x489cc）\n加密字段 0x122dc0e0 ，长度为0xb0\n定位到0x2ec98 是memove函数\nmemove是从0x122dc1c0赋值的数据，\n观察到先在0x2ea28调用处赋值，再0x2ebd8处覆盖2f\u0026mdash;\u0026gt;5f; 2b\u0026mdash;\u0026gt;2d\n0x122dc1c0定位到0x2EA24处是memcpy，在sub_3C8FC前后断点，可以发现，加密数据就是在sub_3C8FC中生成的\n[sub_3C8FC]Base64 一共两次调用该函数\n**summary：**0x90是待base64编码的数据长度，a4参数是待编码数据\n1 2 3 4 sub_3C8FC(__encryptData, v11, size, v17, v18); 1、（0，0， size的指针，指针 ，0x90） 根据0x90是否为3的倍数，进行size = (4 * (0x90 / 3)) | 1; 2、（0x122dc0e0（指针）， 0xC1， size指针，指针（原始数据），0x90) base64编码\n1 2 3 4 #特征 每次循环读取三字节，写入四字节 使用右移 \u0026gt;\u0026gt;、与 \u0026amp;、或 | 来组合 6-bit 的值 所有位运算结果都被当作索引查一个数组 将输入数组 a4 中的内容按 3 字节一组，编码成 4 字节的 Base64 字符，写入 _reulst_ptr。\n1 2 base64字符表 byte_19188 = \u0026#39;a-z\u0026#39;,\u0026#39;A-Z\u0026#39;,0-9,+, \u0026#34;/\u0026#34; 验证是标准的base64编码\n所以sub_3C8FC的a4就是base64前的数据，0x122eb0a0， 长度0x90\n1 2 3 4 5 6 7 8 9 0000: 32 FE 4F 32 A6 7F C3 5C D6 2F 75 49 7E 1E EE FA 2.O2...\\./uI~... 0010: 0C 19 45 EF E9 3B 64 4F 13 B0 BC 24 00 EB E8 49 ..E..;dO...$...I 0020: 03 41 1F A2 23 31 04 A2 A5 1D 06 0A 29 39 25 85 .A..#1......)9%. 0030: 92 6A 2B 56 A9 15 B2 E0 F3 23 CD 60 DB AF 86 DE .j+V.....#.`.... 0040: 56 04 C4 FE 92 8E 69 3C 3B 22 9B 0B BC 55 04 9B V.....i\u0026lt;;\u0026#34;...U.. 0050: 14 69 AF 16 01 9B A3 CF 00 47 0E 4A 3E 27 F3 AD .i.......G.J\u0026gt;\u0026#39;.. 0060: 3F CB F6 EC 3D 41 AC 71 49 5E 6E E5 AA 31 BE 41 ?...=A.qI^n..1.A 0070: 71 72 60 B2 9F 72 44 AF 6A FD 8F BF 0A B4 62 47 qr`..rD.j.....bG 0080: A8 13 51 98 86 4F 0B EB AD 2E ED 84 CF 81 51 2B ..Q..O........Q+ 0x2e8ec\n[sub_39a40] 跳转到0x398D8\n1 2 __int64 __fastcall sub_398D8(_BYTE *a1, __int64 a2, _OWORD *a3, unsigned int a4) a2，a3为0x122eb0a0待base64加密数据的指针 a2=a3=2+sdk版本+jni环境中的值com/shein/armor/a/b-b + android/os/Build-\u0026gt;BRAND + android/os/Build-\u0026gt;MODEL + 时间戳+？？？（这里的691724686）+ ？？？（c7cd4b） 且每个之间以^@拼接\n最后以PKCS7填充\n​\t是某种分组加密算法，继续分析\ndowhile 循环0x9次\n每次处理a2中的（ a2 ~ a2 +7+8）16个字节的数据，每次循环结束后a2 + 16\n1 2 3 4 5 6 7 8 9 10 9x122eb0a0 ~ 0x122eb0af ...... 0x122eb0a0 ~ 0x122eb120 a1[488] = a1[488] ^ a2 a1[489] = a1[489] ^ (a2 + 1) a1[490] = a1[490] ^ (a2 + 2) ...... a1[503] = a1[503] ^ (a2 + 15) 再进入 sub_3984C 函数，将结果位置的v7存在a3中\na1[488~503] 是迭代状态\n根据tracelog可以看出，这里的v7也是16字节，a2和a3一开始是相同指针地址，所以这里v9后续取的也就是sub_3984C处理后的数据\n所以更加推断是AES的CBC模式，接下去去获取iv和key\n[sub_3984C] 核心 根据这几个表索引查到其实是TE表1-4，用于查找表优化\ntrace sub_394F4返回前 0xe4fff2d0L的内存，就是最后的密文\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 ======================sub_394F4================================= 0000: 32 5E 40 5E 33 2E 33 2E 35 5E 40 5E 31 64 30 35 2^@^3.3.5^@^1d05 ======================sub_394F4================================= 0000: 57 9A 78 0A C5 4E A6 6C E7 1C 41 2D 4B 7A D6 CF W.x..N.l..A-Kz.. ======================sub_394F4================================= 0000: 39 2F 76 DF D1 0E 56 79 24 88 DA 40 39 8D DC 2A 9/v...Vy$..@9..* ======================sub_394F4================================= 0000: 65 79 7A C0 16 09 62 90 9C 24 67 68 4A 0E 16 BC eyz...b..$ghJ... ======================sub_394F4================================= 0000: F3 5F 18 63 9F 74 D7 84 CB 47 FE 02 85 EF D8 B9 ._.c.t...G...... ======================sub_394F4================================= 0000: 39 6B A3 92 F7 D0 29 62 75 47 E3 7E CF 75 32 CB 9k....)buG.~.u2. ======================sub_394F4================================= 0000: 4A 29 F1 27 36 AE 91 FC 38 7E 37 78 0B 17 C0 99 J).\u0026#39;6...8~7x.... ======================sub_394F4================================= 0000: BE 7C 1E 43 FC 8E 02 81 05 6D DA C1 A3 C1 E8 D2 .|.C.....m...... ======================sub_394F4================================= 0000: 37 96 2C EC E2 89 2D 56 DD D5 6A 83 11 99 33 76 7.,...-V..j...3v 输入前 输入后sub_394F4\n在0x398D8断点，\n因为a1[488..503]：被不断 xor 操作，结合前面的分析，可以确定是 CBC 的IV = 0000000000000000\n在9次循环下断点，每次的a1 + 488 第一次全0，后续都是上一次的结果，符合aesCBC\n第一轮的才是初始iv\n这几行表示用 a1 地址处的前 16 字节（即 a1 + 0 到 a1 + 16）分别和传入明文块（大端转小端后）做 XOR。\n（a1其实包括了 key、iv、轮密钥这些数据）\n密钥Gibw1p_aX\u0026amp;!0o+_G\t一开始以为是这个卡住了\n每四字节读取作为密钥为\nwbiGa_p10!\u0026amp;XG_+o\n成功恢复，iv和key正确\n明文数据的来源 1 2 3 4 5 6 7 8 9 10 11 12 #0x122eb000 0000: 32 5E 40 5E 33 2E 33 2E 35 5E 40 5E 31 64 30 35 2^@^3.3.5^@^1d05 0010: 65 64 37 38 63 31 65 30 31 33 34 64 35 64 38 35 ed78c1e0134d5d85 0020: 35 36 33 30 38 35 32 36 37 38 66 64 39 66 34 63 5630852678fd9f4c 0030: 66 38 65 62 35 38 66 32 39 39 61 62 63 37 33 39 f8eb58f299abc739 0040: 61 35 33 35 36 61 65 64 38 64 33 62 5E 40 5E 67 a5356aed8d3b^@^g 0050: 6F 6F 67 6C 65 5E 40 5E 4E 65 78 75 73 20 36 50 oogle^@^Nexus 6P 0060: 5E 40 5E 31 37 35 32 33 39 34 33 37 31 35 32 30 ^@^1752394371520 0070: 5E 40 5E 34 32 38 30 34 30 33 30 31 5E 40 5E 38 ^@^428040301^@^8 0080: 36 61 34 64 31 0B 0B 0B 0B 0B 0B 0B 0B 0B 0B 0B 6a4d1........... 2+sdk版本+jni环境中的值com/shein/armor/a/b-b + android/os/Build-\u0026gt;BRAND + android/os/Build-\u0026gt;MODEL + 时间戳+？？？1（这里的691724686）+ ？？？2（c7cd4b） 且每个之间以^@拼接 【1】随机数（以时间戳为种子生成）\n0x48d60找到048D60处的memcpy\n剩下三个参数由栈传递\n1 2 %d\t^@^\t%s\t^@^\t%s\t^@^ %s ^@^ %s ^@^ %s ^@^ %d 2 3.3.5\t1d... google Nexus 6P 1752412831975 853602514 拼接jni environment中的参数\n这个参数就是以时间戳为种子生成的随机数\n​\t存储在0x122d6100中\n【2】md5[-6:]\n前面一共0x7C\n这里添加0x405e32 \u0026ldquo;^@^\u0026rdquo;\n在0x83764处的memove处下断点\nLR=RX@0x120500d8[libsi_armor.so]0x490d8\n0xe4fff3b9 0x838b4 0x122d30aa 0x49014\n在进入0x838b4 （sub_83814时，0x122d30aa 就已经有该值了 ） ，所以和 a2和a3有关\n一开始没有trace到，是因为直接trace了0x122d30aa -0x122d30aa +0x6的范围，扩大范围0x36520\nsub_3639C对a1+1的地址进行hex编码得到最后段数据\n在sub_3AD9C断点，对比前后\u0026amp;v18的结果 因为花指令取出不完整，采用对照trace的跳转地址\n最后进入 sub_3A1E4 （大量的位操作 (\u0026amp;, |, ~, \u0026gt;\u0026gt;) 大量固定的魔法数字 (Magic Numbers)，例如 -389564586, 606105819, -1044525330, -176418897, 1200080426, -1473231341），就是md5加密\n在线验证，是未魔改的md5\n2其实是对前面的数据进行md5后取后6位\n过程中发现密钥是硬编码\n覆盖 在0x2ebfc处覆盖2f\u0026mdash;\u0026gt;5f; 2b\u0026mdash;\u0026gt;2d\n时间戳 通过gettimeofday函数获取时间戳加入到armortokenstr的末尾\n总结 armortoken 参数生成方式：\n固定标识 \u0026quot;S\u0026quot; + \u0026quot;2\u0026quot;\nSDK 版本号（例如 3.3.5）\n密文数据：\ncom/shein/armor/a/b-b的值、设备品牌（android/os/Build-\u0026gt;BRAND）、设备型号（android/os/Build-\u0026gt;MODEL）\n、时间戳、一个以时间戳为种子生成的随机数、由前面数据以及^@^构成的数据进行 MD5 加密后截取后 6 位的值，并可能在末尾进行 PKCS7 填充。 构成明文数据，在使用AES-256 加密算法的 CBC 模式进行加密，然后将 2f (ASCII \u0026lsquo;/\u0026rsquo;) 替换为 5f (ASCII \u0026lsquo;_\u0026rsquo;)，将 2b (ASCII \u0026lsquo;+\u0026rsquo;) 替换为 2d (ASCII \u0026lsquo;-\u0026rsquo;)，再进行HEX编码，最后进行base64编码\n额外知识点 补充一下一些内容\nunidbg中callStaticJniMethod 和 Module.callFunction 方式调用JNI函数的区别和优劣\ncallStaticJniMethod 通过 JNI 层调用 Java 方法\n​\t通过模拟 Java 层调用 JNI 方法，是通过 DalvikVM 来模拟 Android Java 层代码执行，部会模拟 JNI 注册，参数转换，以及回调 Native 层。\n​\t逻辑性较完整，因为是模拟的从java层去调用，适合注册了native的方法\nmodule.callFunction 直接调用 native 函数地址\n​\t直接调用 SO 文件中某个函数的地址，跳过 Java 层、JNI 封装，直接进入 native 层执行函数代码。\n​\t直接调用特定函数，可用于定位、反调试、HOOK 点、内部逻辑执行。\nNumber number = module.callFunction() 这个 number 的意义是：\n如果 native 函数返回的是一个整数（如 int 或 jint），你可以用 number.intValue()\n如果函数返回一个对象（如 jstring 或其他 jobject），那么返回值是该对象在虚拟机中的 reference ID\n安卓系统静态常量（用于部分环境补充）\n字段 命令 示例返回 Build.BRAND adb shell getprop ro.product.brand google Build.MODEL adb shell getprop ro.product.model MI 9 Build.MANUFACTURER adb shell getprop ro.product.manufacturer Xiaomi Build.DEVICE adb shell getprop ro.product.device cepheus Build.FINGERPRINT adb shell getprop ro.build.fingerprint Xiaomi/cepheus/cepheus:10/QKQ1... Build.VERSION.SDK_INT adb shell getprop ro.build.version.sdk 30 Build.VERSION.RELEASE adb shell getprop ro.build.version.release 11 参考资料 https://mp.weixin.qq.com/s/nvNCmXXAbstYZUkxDZ9ZnQ\nhttps://www.cnblogs.com/kentle/p/15529251.html\n","permalink":"https://SimpsonGet.github.io/zh/posts/tech/shenin/","summary":"海外电商APP希Y某的armortoken参数生成算法逆向分析","title":"海外电商APP希Y某参数分析"},{"content":"\r样本：超星学习通[v6.5.9]\n包名：com.chaoxing.mobile\njava层分析 梆梆加固特征\n程序入口点\n根据系统架构选择\n在load()函数后，使用doAttach()利用反射的手段调用代码，那么libDexHelper.so即为对原始dex文件的释放\nnative层分析 so文件：libDexHelper.so\n直接打开apk中的so文件，可以发现so文件被加密\n获取解密后的so文件 dump解密so文件的时机\n博文给出的是在android_dlopen_ext时机\ndump的逻辑是修改目标段的读写执行权限，再将内存读到缓冲区，写入目标地址\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 function hook_dlopen(){ var soName = \u0026#34;libDexHelper.so\u0026#34; Interceptor.attach(Module.findExportByName(null, \u0026#39;android_dlopen_ext\u0026#39;),{ onEnter : function(args){ //arg[0] 是要加载的so的路径 if(args[0] != null){ let loadPath = Memory.readUtf8String(args[0]) console.log(\u0026#34;dlopen call is: \u0026#34; + loadPath + \u0026#34;\\n\u0026#34;) if (loadPath.includes(soName)){ this.flag = 1 } } },onLeave:function(retval){ console.log(\u0026#34;dlopen return\\n\u0026#34;) if (this.flag === 1){ dumpSo(soName) this.flag = 0 } } }) } function dumpSo(filename){ var handle = Process.getModuleByName(filename) console.log(\u0026#34;[dump] start dumping ---------\u0026#34; + handle) var path = \u0026#34;/data/data/com.chaoxing.mobile/\u0026#34; + handle.name + \u0026#34;_\u0026#34; + handle.base + \u0026#34;_\u0026#34; + ptr(handle.size) + \u0026#34;.so\u0026#34; var file_handle = new File(path, \u0026#34;wb\u0026#34;) if(!file_handle){ console.log(\u0026#34;[dump] dump failed\u0026#34;) return } Memory.protect(ptr(handle.base), handle.size, \u0026#39;rwx\u0026#39;) var libbuffer = ptr(handle.base).readByteArray(handle.size) file_handle.webkitRelativePath(libbuffer) file_handle.close() console.log(\u0026#34;[dump] dump finished and path is: \u0026#34; + path) } setImmediate(hook_dlopen) 内存中dump下来的so文件需要进行修复，这里使用sofixer修复\n1 2 3 4 5 sofixer -s soruce.so -o fix.so -m 0x0 -d -s 待修复的so路径 -o 修复后的so路径 -m 內存dump的基地址(16位) 0xABC -d 输出debug信息 修复后\n还有一些函数名被混淆，用idapython恢复为sub_offset\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 import idautils import idc def rename_function(): for func_ea in idautils.Functions(): funcName = idc.get_func_name(func_ea) if funcName.startswith(\u0026#34;pS\u0026#34;) or funcName.startswith(\u0026#34;j_\u0026#34;) or funcName.startswith(\u0026#34;p5\u0026#34;): editName = f\u0026#34;sub_{func_ea:X}\u0026#34; else: continue if idc.set_name(func_ea, editName, idc.SN_NOWARN): print(f\u0026#34;[Success] {funcName} ---\u0026gt; {editName} in (0x{func_ea:X})\u0026#34;) rename_function() 分析 JNI_Onload中\n1 2 3 4 5 6 7 8 9 com/secneo/apkwrapper/H (Ljava/lang/String;)I (Ljava/lang/String;I)V (I)V (Ljava/lang/String;)Ljava/lang/String; d com/secneo/apkwrapper/AW ()V pn (Landroid/content/Context;Landroid/app/Application;)V hn sub_3199C函数集合了各种检测\n有很多跳板函数，需要结合0x71aeb83000内存加载地址去跳转\n0x430C0实现对 libc.so 中 read、open64、openat64等\t函数的 hook 或替换。\nsub_52BC4中\nlibc符号表恢复 一些thunk函数0x7254D05110其实是libc中的\nbase = 0x7254c9a000\n导出libc符号表 1 nm -D libc.so \u0026gt; libc_symbols.txt 导入到libdexhelp中 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 import idautils import ida_bytes import idc libc_base = 0x7254c9a000 # /proc/pid/maps/ 获得 libc_symbols = {} with open(\u0026#39;./libc_symbols.txt\u0026#39;, \u0026#39;r\u0026#39;) as f: for line in f: parts = line.strip().split() if len(parts) \u0026gt;= 3: offset = int(parts[0], 16) name = parts[2].split(\u0026#39;@@\u0026#39;)[0] # 去掉版本号 libc_symbols[libc_base + offset] = name # 遍历当前段中的 qword for ea in idautils.Segments(): segname = idc.get_segm_name(ea) if \u0026#39;.data\u0026#39; in segname or \u0026#39;.got\u0026#39; in segname: start = idc.get_segm_start(ea) end = idc.get_segm_end(ea) for addr in range(start, end, 8): # 64位系统 if idc.is_qword(ida_bytes.get_full_flags(addr)): ptr_val = idc.get_qword(addr) if ptr_val in libc_symbols: name = f\u0026#34;{libc_symbols[ptr_val]}_ptr\u0026#34; idc.set_name(addr, name, idc.SN_CHECK) print(f\u0026#34;[success] edit the {addr} ---\u0026gt; {name}\u0026#34;) 【sub_52BC4】检测frida 1 2 3 4 5 6 7 //libc部分函数的参数及用法 sendto（int sockfd， const void *msg，int len , unsigned int flags， const struct sockaddr *to， int tolen） // recvfrom（int sockfd，void *buf，int len，unsigned int lags，struct sockaddr *from，int *fromlen // access(const char* pathname, int mode) //检查调用进程是否能对pathname指定的文件作mode操作，成功执行返回0，失败为-1 1 2 3 4 5 6 7 8 qword_EDE40 = GET/ws HTTP/1.1 Upgrade: websocket Connection: Upgrade Sec-WebSocket-Key: nmmA32Q10Aqj2vWK w== Sec-WebSocket-Version: 13 Host: 127.0.0.1:27042 1 2 3 4 5 v16[0] = 2; //这个赋值操作看起来像是设置某个协议族（family）。 在常见的网络编程中，AF_INET 的值是 2，表示 IPv4 地址族。因此，这可能是在初始化一个 sockaddr_in 结构体的第一个字段 sin_family。 v4 = 20000; 这个变量 v4 被设置为 20000。考虑到后续的操作，这个值很可能是用于设置端口号。 v16[1] = bswap32(v4) \u0026gt;\u0026gt; 16; 这里对 v4 进行了字节交换 (bswap32) 并右移 16 位。字节交换通常用于处理不同字节序之间的转换（例如，从主机字节序到网络字节序）。假设 bswap32(v4) 将 v4 的字节顺序反转，对于值 20000（即十六进制的 0x4E20），其字节交换后的结果仍然是 0x4E20（因为它是32位整数，且高位字节为零）。然后将其右移16位，得到的结果是 0x0000。 根据27042端口，即 本地的 Frida Server 默认监听端口\n1 2 3 4 这段代码的行为 用 AUTH\\r\\n 探测服务是否开启 发送标准 WebSocket 请求到 127.0.0.1:27042，分析是否返回 Sec-WebSocket-Accept，判断 WebSocket 是否被接受 如果成功，说明本地 Frida 正在运行，被识别 【sub_4CB6C】环境检测 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 xmmword_C4200 = [-2, -3, -1, -2, -3, -1, -2, -3, -1, -2, -3, -1, -2, -3, -1, -2] def v37_a(old, num): print(chr(ord(old) -num)) def common(oldstr): tmp = \u0026#34;\u0026#34; tmp2 = \u0026#34;\u0026#34; tmp += oldstr[0] if (len(oldstr) \u0026gt; 16): tmp2 = oldstr[17::] for i in range(16): tmp += chr(ord(oldstr[i + 1]) + xmmword_C4200[i]) if (len(oldstr) \u0026gt; 16): tmp += tmp2 return tmp def v37_1(): v37 = \u0026#34;0uejp2/ersg2ed011pbiltm1ed\u0026#34; a0uejp2Ersg2ed0 = \u0026#34;0uejp2/ersg2ed011pbiltm1ed\u0026#34; # a(a0uejp2Ersg2ed0[17], 3) # a(a0uejp2Ersg2ed0[18] ,1) # a(a0uejp2Ersg2ed0[19] , 2) # a(a0uejp2Ersg2ed0[20] , 3) # a(a0uejp2Ersg2ed0[21] , 1) # a(a0uejp2Ersg2ed0[22] , 2) # a(a0uejp2Ersg2ed0[23] , 3) # a(a0uejp2Ersg2ed0[24] , 1) # a(a0uejp2Ersg2ed0[25] , 2) v37 = \u0026#34;/uejp2/ersg2ed011magisk.db\u0026#34; v37 = common(v37) return v37 def v45_1(): v45 = \u0026#34;0uejp2/ersg2nkusqr\u0026#34; v45 = \u0026#34;/uejp2/ersg2nkusqr\u0026#34; v45 = common(v45) return v45 def v50_1(): v50 = \u0026#34;0u|tvhn1ejp2ncjjuk\u0026#34; v50 = \u0026#34;/u|tvhn1ejp2ncjjuk\u0026#34; v50 = common(v50) return v50 print(\u0026#34;v37 === \u0026#34;,v37_1()) print(\u0026#34;v45 === \u0026#34;,v45_1()) print(\u0026#34;v50 === \u0026#34;,v50_1()) 1 2 3 4 5 6 /sbin/.core/db-0/magisk.db .core是使用的隐藏目录，包含其核心运行时数据。数据库存储设置和root权限 /sbin/.core/mirror\t是 Magisk 的一个关键功能 —— system-as-root 镜像挂载点\t/system/bin/magisk\t是主程序 /system/usr/we-need-root/ /system/bin/failsafe/ 通过一些字符串的拼接解密获得文件路径，然后使用access函数判断\n1、/sbin/.core/mirror\n2、/data/local/su\n3、/data/local/bin/su\n4、 /data/local/xbin/su\n5、/sbin/su\n6、/su/bin/su\n7、/system/bin/su\n8、/system/bin/.ext/su\n9、/system/bin/failsafe/su\n10、/system/sd/xbin/su\n11、/system/usr/we-need-root/su\n12、/system/xbin/su\n调用 openat 中断访问/proc/self/attr/prev文件获取数值与字符串u:r:zygote:s0比对调用\nSELinux 上下文（SELinux Context）检测，用于判断当前进程是否运行在预期的安全上下文中\n1 2 3 4 5 6 7 8 user:role:type:sensitivity u:r:zygote:s0 → zygote 进程的安全上下文 /proc/self/attr/prev 是什么？ 这是 SELinux 提供的一个接口文件，表示 当前进程的上一个安全上下文 正常情况下，App 是由 Zygote 启动的，它的 prev 上下文是 u:r:zygote:s0 如果修改了启动方式，比如通过 su 提权后再启动这个 App，那么 prev 上下文就会变成 u:r:su:s0 或其他非 zygote 上下文 ro.build.tags 主要用于标识构建类型如果检测到 test-keys 而不是 release-keys，则可能提示用户当前系统存在潜在的安全问题。\n【sub_52EA0】java层检测 1 2 3 4 5 int pthread_create(pthread_t *thread, const pthread_attr_t *attr, void *(*start_routine) (void *), void *arg); //\\3) void *(*start_routine) (void *)：以函数指针的方式指明新建线程需要执行的函数，该函数的参数最多有 1 个（可以省略不写），形参和返回值的类型都必须为 void* 类型。void* 类型又称空指针类型，表明指针所指数据的类型是未知的。使用此类型指针时，我们通常需要先对其进行强制类型转换，然后才能正常访问指针指向的数据。 根据pthread_create函数的使用方法得x2寄存器存放的sub_52EA0函数，其实是将要开启新线程执行的函数地址\n线程异步执行sub_52EA0\n这边需要根据汇编手动恢复该函数的签名（因为是thunk跳板函数所以ida没有自动识别），也可以使用idapython去做自动化批量设置\n1 j_execl_ptr(\u0026#34;/system/bin/app_process\u0026#34;, \u0026#34;/system/bin/app_process\u0026#34;, \u0026#34;/system/bin\u0026#34;, “--nice-name=zygisk.so”, \u0026#34;com.secneo.apkwrapper.H\u0026#34;, \u0026#34;--write-fd\u0026#34;, v12, \u0026#34;--flags\u0026#34;, 0, 0LL); so层通过excel对java层进行检测，检测tracepid\n​\t【sub_4D638】hook框架检测 太多了就恢复两个看看\nisExportFunctionExist是对目标so以绝对路径的方式\n通过mmap进行映射到maps中，与原来已经在maps的so在内存中的导出函数进行比对前16个字节，\n如果比对不一致则返回1，否则返回0，如果maps没有这个so则返回0，如果maps中有这个so但没有这个要搜索的导出函数则返回-1。\n通过对比libart.so中导出函数的前16字节判断是否被修改。\n检查环境变量 CLASSPATH 是否存在、是否非空、且是否长度大于等于 6。为了判断当前运行环境是否被注入、是否正确设置、是否伪装成功等。\n【sub_4E308】虚拟机检测 1 2 3 4 5 6 7 8 9 10 11 在Android开发中，可以通过c接口直接获取设备属性，系统接口为： int __system_property_get(const char* name, char* value)； j___system_property_get_ptr(\u0026#34;ro.bluetooth.name\u0026#34;, a1) j___system_property_get_ptr(\u0026#34;vmos.browser.home\u0026#34;, a1) j___system_property_get_ptr(\u0026#34;vmprop.wifissid\u0026#34;, a1) j___system_property_get_ptr(\u0026#34;ro.product.manufacturer\u0026#34;, a1) j___system_property_get_ptr(\u0026#34;ro.product.model\u0026#34;, a1) j___system_property_get_ptr(\u0026#34;ro.product.manufacturer\u0026#34;, a1) ueventd.ttVM_x86.rc、init.ttVM_x86.rc这些是 BlueStacks 虚拟机镜像文件，一般不会在真实设备中出现。\n判断这些文件是否存在且是普通文件，\t关键字判断等\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 #其他博客的总结 调用 _system_property_get(\u0026#34;ro.bluetooth.name\u0026#34;, resultAddr) ro.ip.name ro.product.manufacturer ro.product.model 这么四个属性对应的数值与\u0026#34;vmos\u0026#34;（\u0026#34;vmos\u0026#34;代表虚拟机）比较 调用 _system_property_get(\u0026#34;vmos.browser.home\u0026#34;, resultAddr) vmos.camera.enable ro.vmos.simplest.rom persist.vmos.setting.show persist.vmos.tool.show 这么四个属性对应的数值与0x30作比较（满足一定的条件resultAddr会被自动赋值为0x30）比较，此处是比较不相同 调用 _system_property_get(\u0026#34;vmprop.wifissid\u0026#34;, resultAddr) 调用 _system_property_get(\u0026#34;persist.vmos.root.enable\u0026#34;, resultAddr) 调用 _system_property_get(\u0026#34;persist.vmos.root.show\u0026#34;, resultAddr) persist.vmos.skills.show persist.vmos.xposed.enable persist.vmos.xposed.show ro.vmos.simplest.rom vmos.camera.enable 上述调用_system_property_get获取属性值之后，如果_system_property_get的返回值是否大于0 调用 access 访问 /system/priv-app/vmos-pro-intent 是否存在 fopen 打开 //proc/version.osed.show 文件，调用fgets获取文件内容，是否存在字符串\u0026#34;titan\u0026#34; fopen 打开 //property_contexts.show 文件，调用fgets获取文件内容，是否存在字符串\u0026#34;titan\u0026#34; fopen 打开 //service_contexts 文件，调用fgets获取文件内容，是否存在字符串\u0026#34;titan\u0026#34; 【sub_56C10】调试器检测 通过foepn 打开/proc/pid/status文件\n调用sleep(1)循环检查status文件检测“state”标志和\u0026quot;TracerPid:\u0026ldquo;标志\n如果获取的pid不为0且跟调用getpid函数获取自身pid的不一致则调用中断 kill 关闭调试进程\n【解密DEX】 加密数据存放于最大的dex中，根据dexdata0定位\n每次申请0x20000大小循环解密\nsub_38E04\n三个参数分别是：被加密数据的地址、存放解密后数据的位置、参与解密运算的32字节密钥\n1 2 makeInMemoryDexElements 的核心作用是： 将内存中的 DEX 文件（或 ZIP/APK 中的 DEX）转换为 DexPathList 中的 Element 数组，供 ClassLoader 使用。 最后使用dexfile::loader加载解密后的dex文件\n参考文献 https://bbs.kanxue.com/thread-191649.htm\nhttps://zhuanlan.zhihu.com/p/685239153\nhttps://x2d1.github.io/2025/04/09/bangbang_protect_1/#%E5%88%9D%E5%A7%8B%E5%8C%96%E9%83%A8%E5%88%86\n","permalink":"https://SimpsonGet.github.io/zh/posts/tech/bangbnagjiagu/","summary":"分析梆梆加固中的对设备相关检测","title":"梆梆加固免费壳分析"},{"content":"\r联系方式 Email: foreverstudy001.gmail.com GitHub: https://github.com/SimpsonGet ","permalink":"https://SimpsonGet.github.io/zh/about/","summary":"\u003cimg src=\"/images/avatar.jpg\" alt=\"我的头像\" width=\"150\"\u003e\r\n\u003ch2 id=\"联系方式\"\u003e联系方式\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eEmail: foreverstudy001.gmail.com\u003c/li\u003e\n\u003cli\u003eGitHub: \u003ca href=\"https://github.com/SimpsonGet\"\u003ehttps://github.com/SimpsonGet\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c!-- #### 技术栈\r\n\r\n---\r\n\r\n## 我的兴趣\r\n\r\n-- --\u003e","title":"关于"}]